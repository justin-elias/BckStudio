# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
    "The Stage of an object"
    stage: Stage!
}

union PolicyPolicyTextRichTextEmbeddedTypes = Asset

type Aggregate {
    count: Int!
}

"Asset system model"
type Asset implements Node {
    "Alt text for html component accessibility"
    altText: String
    "The time the document was created"
    createdAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Asset!]!
    "The file name"
    fileName: String!
    "The file handle"
    handle: String!
    "The height of the file"
    height: Float
    "List of Asset versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    imageWebsiteDefaultImage(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `imageWebsiteDefaultImage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: WebsiteDefaultImageOrderByInput,
        skip: Int,
        where: WebsiteDefaultImageWhereInput
    ): [WebsiteDefaultImage!]!
    instructorHeadshotImage(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `instructorHeadshotImage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: InstructorOrderByInput,
        skip: Int,
        where: InstructorWhereInput
    ): [Instructor!]!
    "System Locale field"
    locale: Locale!
    "Get the other localizations for this document"
    localizations(
        "Decides if the current locale should be included or not"
        includeCurrent: Boolean! = false,
        "Potential locales that should be returned"
        locales: [Locale!]! = [en]
    ): [Asset!]!
    "The mime type of the file"
    mimeType: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "The file size"
    size: Float
    staffPictureInstructor(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `staffPictureInstructor` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: InstructorOrderByInput,
        skip: Int,
        where: InstructorWhereInput
    ): [Instructor!]!
    "System stage field"
    stage: Stage!
    title: String
    "The time the document was updated"
    updatedAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the url for the asset with provided transformations applied."
    url(transformation: AssetTransformationInput): String!
    "The file width"
    width: Float
}

"A connection to a list of items."
type AssetConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [AssetEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AssetEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Asset!
}

type BatchPayload {
    "The number of nodes that have been affected by the Batch operation."
    count: Long!
}

"Classes available at BCK"
type Class implements Node {
    "Text on booking button"
    buttonText: String!
    "Categories that appear on website under classes"
    classCategory(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `classCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): ClassCategory
    "Bullet Points to describe the class. If wanting a paragraph instead, just use one entry."
    classDescriptionList: [String!]!
    """

    Subtitles that appear under the instructor's name. ex:
    Class: Tuesdays 6:45pm-9:30pm
    """
    classInfoList: [String!]!
    "The http address from the Acuity Direct Scheduling Link"
    classLink: String
    className: String!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    disableBookingButton: Boolean!
    "Title to display on the website if different than the Class title"
    displayTitle: String
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Class!]!
    "List of Class versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    instructor(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `instructor` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Instructor
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"Categories that display on website"
type ClassCategory implements Node {
    "Title to display on website"
    categoryTitle: String!
    "List of classes assigned to category"
    classes(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `classes` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: ClassOrderByInput,
        skip: Int,
        where: ClassWhereInput
    ): [Class!]!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "A description that appears under the category title"
    description: String
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [ClassCategory!]!
    "List of ClassCategory versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type ClassCategoryConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ClassCategoryEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ClassCategoryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ClassCategory!
}

"A connection to a list of items."
type ClassConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ClassEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ClassEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Class!
}

"Representing a color value comprising of HEX, RGBA and css color values"
type Color {
    css: String!
    hex: Hex!
    rgba: RGBA!
}

type DocumentVersion {
    createdAt: DateTime!
    data: Json
    id: ID!
    revision: Int!
    stage: Stage!
}

"A Frequently Asked Question"
type Faq implements Node {
    answer: RichText!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Faq!]!
    faqPage(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `faqPage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: FaqPageOrderByInput,
        skip: Int,
        where: FaqPageWhereInput
    ): [FaqPage!]!
    "List of Faq versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    markdown: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "A common question"
    question: String!
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type FaqConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [FaqEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type FaqEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Faq!
}

"List of Frequently Asked Questions "
type FaqPage implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [FaqPage!]!
    "List of FaqPage versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    listOfFaQs(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `listOfFaQs` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: FaqOrderByInput,
        skip: Int,
        where: FaqWhereInput
    ): [Faq!]!
    pageTitle: String!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type FaqPageConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [FaqPageEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type FaqPageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: FaqPage!
}

type Instructor implements Node {
    "A descriptive Bio focused on the instructor's teaching qualifications"
    bio: RichText
    class(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `class` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: ClassOrderByInput,
        skip: Int,
        where: ClassWhereInput
    ): [Class!]!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    defaultInstructor: Boolean
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Instructor!]!
    firstName: String!
    "Professional quality headshot to be displayed on the instructor's bio page"
    headshotImage(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `headshotImage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Asset
    "List of Instructor versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    "Similiar to the instructor's artist statement, but focused on their goals for their class"
    instructorStatement: RichText
    "Is on staff at bck"
    isStaff: Boolean!
    lastName: String!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Background Bio for staff members"
    staffBio: RichText
    "Image to go in the about us section"
    staffPicture(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `staffPicture` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Asset
    "The position title of staff member"
    staffTitle: String
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type InstructorConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [InstructorEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type InstructorEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Instructor!
}

"Representing a geolocation point with latitude and longitude"
type Location {
    distance(from: LocationInput!): Float!
    latitude: Float!
    longitude: Float!
}

type MembershipCategory implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [MembershipCategory!]!
    "List of MembershipCategory versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    membershipTiers(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `membershipTiers` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: MembershipTierOrderByInput,
        skip: Int,
        where: MembershipTierWhereInput
    ): [MembershipTier!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type MembershipCategoryConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [MembershipCategoryEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type MembershipCategoryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: MembershipCategory!
}

"Studio Membership Levels"
type MembershipTier implements Node {
    buttonText: String!
    "Contained button should be the choice you want customer's attention drawn to most.  "
    buttonVariant: ButtonVariant!
    category(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `category` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): MembershipCategory
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Each line will become a bullet point"
    description: [String!]!
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [MembershipTier!]!
    "List of MembershipTier versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    "Link or value to the purchase api"
    inputValue: String!
    "Price as whole integer."
    price: Int!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    "Is the membership month or pass type?"
    term: MembershipTerm!
    testCategory(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `testCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: TestCategoryOrderByInput,
        skip: Int,
        where: TestCategoryWhereInput
    ): [TestCategory!]!
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type MembershipTierConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [MembershipTierEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type MembershipTierEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: MembershipTier!
}

type Mutation {
    "Create one asset"
    createAsset(data: AssetCreateInput!): Asset @deprecated(reason : "Asset mutations will be overhauled soon")
    "Create one class"
    createClass(data: ClassCreateInput!): Class
    "Create one classCategory"
    createClassCategory(data: ClassCategoryCreateInput!): ClassCategory
    "Create one faq"
    createFaq(data: FaqCreateInput!): Faq
    "Create one faqPage"
    createFaqPage(data: FaqPageCreateInput!): FaqPage
    "Create one instructor"
    createInstructor(data: InstructorCreateInput!): Instructor
    "Create one membershipCategory"
    createMembershipCategory(data: MembershipCategoryCreateInput!): MembershipCategory
    "Create one membershipTier"
    createMembershipTier(data: MembershipTierCreateInput!): MembershipTier
    "Create one page"
    createPage(data: PageCreateInput!): Page
    "Create one policy"
    createPolicy(data: PolicyCreateInput!): Policy
    "Create one testCategory"
    createTestCategory(data: TestCategoryCreateInput!): TestCategory
    "Create one websiteDefaultImage"
    createWebsiteDefaultImage(data: WebsiteDefaultImageCreateInput!): WebsiteDefaultImage
    "Delete one asset from _all_ existing stages. Returns deleted document."
    deleteAsset(
        "Document to delete"
        where: AssetWhereUniqueInput!
    ): Asset
    "Delete one class from _all_ existing stages. Returns deleted document."
    deleteClass(
        "Document to delete"
        where: ClassWhereUniqueInput!
    ): Class
    "Delete one classCategory from _all_ existing stages. Returns deleted document."
    deleteClassCategory(
        "Document to delete"
        where: ClassCategoryWhereUniqueInput!
    ): ClassCategory
    "Delete one faq from _all_ existing stages. Returns deleted document."
    deleteFaq(
        "Document to delete"
        where: FaqWhereUniqueInput!
    ): Faq
    "Delete one faqPage from _all_ existing stages. Returns deleted document."
    deleteFaqPage(
        "Document to delete"
        where: FaqPageWhereUniqueInput!
    ): FaqPage
    "Delete one instructor from _all_ existing stages. Returns deleted document."
    deleteInstructor(
        "Document to delete"
        where: InstructorWhereUniqueInput!
    ): Instructor
    "Delete many Asset documents"
    deleteManyAssets(
        "Documents to delete"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyAssetsConnection)")
    "Delete many Asset documents, return deleted documents"
    deleteManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Delete many ClassCategory documents"
    deleteManyClassCategories(
        "Documents to delete"
        where: ClassCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyClassCategoriesConnection)")
    "Delete many ClassCategory documents, return deleted documents"
    deleteManyClassCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: ClassCategoryManyWhereInput
    ): ClassCategoryConnection!
    "Delete many Class documents"
    deleteManyClasses(
        "Documents to delete"
        where: ClassManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyClassesConnection)")
    "Delete many Class documents, return deleted documents"
    deleteManyClassesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: ClassManyWhereInput
    ): ClassConnection!
    "Delete many FaqPage documents"
    deleteManyFaqPages(
        "Documents to delete"
        where: FaqPageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyFaqPagesConnection)")
    "Delete many FaqPage documents, return deleted documents"
    deleteManyFaqPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: FaqPageManyWhereInput
    ): FaqPageConnection!
    "Delete many Faq documents"
    deleteManyFaqs(
        "Documents to delete"
        where: FaqManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyFaqsConnection)")
    "Delete many Faq documents, return deleted documents"
    deleteManyFaqsConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: FaqManyWhereInput
    ): FaqConnection!
    "Delete many Instructor documents"
    deleteManyInstructors(
        "Documents to delete"
        where: InstructorManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyInstructorsConnection)")
    "Delete many Instructor documents, return deleted documents"
    deleteManyInstructorsConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: InstructorManyWhereInput
    ): InstructorConnection!
    "Delete many MembershipCategory documents"
    deleteManyMembershipCategories(
        "Documents to delete"
        where: MembershipCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyMembershipCategoriesConnection)")
    "Delete many MembershipCategory documents, return deleted documents"
    deleteManyMembershipCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: MembershipCategoryManyWhereInput
    ): MembershipCategoryConnection!
    "Delete many MembershipTier documents"
    deleteManyMembershipTiers(
        "Documents to delete"
        where: MembershipTierManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyMembershipTiersConnection)")
    "Delete many MembershipTier documents, return deleted documents"
    deleteManyMembershipTiersConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: MembershipTierManyWhereInput
    ): MembershipTierConnection!
    "Delete many Page documents"
    deleteManyPages(
        "Documents to delete"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyPagesConnection)")
    "Delete many Page documents, return deleted documents"
    deleteManyPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: PageManyWhereInput
    ): PageConnection!
    "Delete many Policy documents"
    deleteManyPolicies(
        "Documents to delete"
        where: PolicyManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyPoliciesConnection)")
    "Delete many Policy documents, return deleted documents"
    deleteManyPoliciesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: PolicyManyWhereInput
    ): PolicyConnection!
    "Delete many TestCategory documents"
    deleteManyTestCategories(
        "Documents to delete"
        where: TestCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyTestCategoriesConnection)")
    "Delete many TestCategory documents, return deleted documents"
    deleteManyTestCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: TestCategoryManyWhereInput
    ): TestCategoryConnection!
    "Delete many WebsiteDefaultImage documents"
    deleteManyWebsiteDefaultImages(
        "Documents to delete"
        where: WebsiteDefaultImageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (deleteManyWebsiteDefaultImagesConnection)")
    "Delete many WebsiteDefaultImage documents, return deleted documents"
    deleteManyWebsiteDefaultImagesConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: WebsiteDefaultImageManyWhereInput
    ): WebsiteDefaultImageConnection!
    "Delete one membershipCategory from _all_ existing stages. Returns deleted document."
    deleteMembershipCategory(
        "Document to delete"
        where: MembershipCategoryWhereUniqueInput!
    ): MembershipCategory
    "Delete one membershipTier from _all_ existing stages. Returns deleted document."
    deleteMembershipTier(
        "Document to delete"
        where: MembershipTierWhereUniqueInput!
    ): MembershipTier
    "Delete one page from _all_ existing stages. Returns deleted document."
    deletePage(
        "Document to delete"
        where: PageWhereUniqueInput!
    ): Page
    "Delete one policy from _all_ existing stages. Returns deleted document."
    deletePolicy(
        "Document to delete"
        where: PolicyWhereUniqueInput!
    ): Policy
    "Delete one testCategory from _all_ existing stages. Returns deleted document."
    deleteTestCategory(
        "Document to delete"
        where: TestCategoryWhereUniqueInput!
    ): TestCategory
    "Delete one websiteDefaultImage from _all_ existing stages. Returns deleted document."
    deleteWebsiteDefaultImage(
        "Document to delete"
        where: WebsiteDefaultImageWhereUniqueInput!
    ): WebsiteDefaultImage
    "Publish one asset"
    publishAsset(
        "Optional localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: AssetWhereUniqueInput!,
        "Whether to include the default locale when publishBase is set"
        withDefaultLocale: Boolean = true
    ): Asset
    "Publish one class"
    publishClass(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ClassWhereUniqueInput!
    ): Class
    "Publish one classCategory"
    publishClassCategory(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: ClassCategoryWhereUniqueInput!
    ): ClassCategory
    "Publish one faq"
    publishFaq(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: FaqWhereUniqueInput!
    ): Faq
    "Publish one faqPage"
    publishFaqPage(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: FaqPageWhereUniqueInput!
    ): FaqPage
    "Publish one instructor"
    publishInstructor(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: InstructorWhereUniqueInput!
    ): Instructor
    "Publish many Asset documents"
    publishManyAssets(
        "Document localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: AssetManyWhereInput,
        "Whether to include the default locale when publishBase is true"
        withDefaultLocale: Boolean = true
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyAssetsConnection)")
    "Publish many Asset documents"
    publishManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        "Document localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: AssetManyWhereInput,
        "Whether to include the default locale when publishBase is true"
        withDefaultLocale: Boolean = true
    ): AssetConnection!
    "Publish many ClassCategory documents"
    publishManyClassCategories(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ClassCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyClassCategoriesConnection)")
    "Publish many ClassCategory documents"
    publishManyClassCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ClassCategoryManyWhereInput
    ): ClassCategoryConnection!
    "Publish many Class documents"
    publishManyClasses(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ClassManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyClassesConnection)")
    "Publish many Class documents"
    publishManyClassesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: ClassManyWhereInput
    ): ClassConnection!
    "Publish many FaqPage documents"
    publishManyFaqPages(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: FaqPageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyFaqPagesConnection)")
    "Publish many FaqPage documents"
    publishManyFaqPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: FaqPageManyWhereInput
    ): FaqPageConnection!
    "Publish many Faq documents"
    publishManyFaqs(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: FaqManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyFaqsConnection)")
    "Publish many Faq documents"
    publishManyFaqsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: FaqManyWhereInput
    ): FaqConnection!
    "Publish many Instructor documents"
    publishManyInstructors(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: InstructorManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyInstructorsConnection)")
    "Publish many Instructor documents"
    publishManyInstructorsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: InstructorManyWhereInput
    ): InstructorConnection!
    "Publish many MembershipCategory documents"
    publishManyMembershipCategories(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: MembershipCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyMembershipCategoriesConnection)")
    "Publish many MembershipCategory documents"
    publishManyMembershipCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: MembershipCategoryManyWhereInput
    ): MembershipCategoryConnection!
    "Publish many MembershipTier documents"
    publishManyMembershipTiers(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: MembershipTierManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyMembershipTiersConnection)")
    "Publish many MembershipTier documents"
    publishManyMembershipTiersConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: MembershipTierManyWhereInput
    ): MembershipTierConnection!
    "Publish many Page documents"
    publishManyPages(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyPagesConnection)")
    "Publish many Page documents"
    publishManyPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: PageManyWhereInput
    ): PageConnection!
    "Publish many Policy documents"
    publishManyPolicies(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: PolicyManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyPoliciesConnection)")
    "Publish many Policy documents"
    publishManyPoliciesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: PolicyManyWhereInput
    ): PolicyConnection!
    "Publish many TestCategory documents"
    publishManyTestCategories(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: TestCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyTestCategoriesConnection)")
    "Publish many TestCategory documents"
    publishManyTestCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: TestCategoryManyWhereInput
    ): TestCategoryConnection!
    "Publish many WebsiteDefaultImage documents"
    publishManyWebsiteDefaultImages(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: WebsiteDefaultImageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (publishManyWebsiteDefaultImagesConnection)")
    "Publish many WebsiteDefaultImage documents"
    publishManyWebsiteDefaultImagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: WebsiteDefaultImageManyWhereInput
    ): WebsiteDefaultImageConnection!
    "Publish one membershipCategory"
    publishMembershipCategory(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: MembershipCategoryWhereUniqueInput!
    ): MembershipCategory
    "Publish one membershipTier"
    publishMembershipTier(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: MembershipTierWhereUniqueInput!
    ): MembershipTier
    "Publish one page"
    publishPage(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: PageWhereUniqueInput!
    ): Page
    "Publish one policy"
    publishPolicy(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: PolicyWhereUniqueInput!
    ): Policy
    "Publish one testCategory"
    publishTestCategory(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: TestCategoryWhereUniqueInput!
    ): TestCategory
    "Publish one websiteDefaultImage"
    publishWebsiteDefaultImage(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: WebsiteDefaultImageWhereUniqueInput!
    ): WebsiteDefaultImage
    "Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishAsset(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Optional locales to unpublish. Unpublishing the default locale will completely remove the document from the selected stages"
        locales: [Locale!],
        "Unpublish complete document including default localization and relations from stages. Can be disabled."
        unpublishBase: Boolean = true,
        "Document to unpublish"
        where: AssetWhereUniqueInput!
    ): Asset
    "Unpublish one class from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishClass(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: ClassWhereUniqueInput!
    ): Class
    "Unpublish one classCategory from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishClassCategory(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: ClassCategoryWhereUniqueInput!
    ): ClassCategory
    "Unpublish one faq from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishFaq(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: FaqWhereUniqueInput!
    ): Faq
    "Unpublish one faqPage from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishFaqPage(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: FaqPageWhereUniqueInput!
    ): FaqPage
    "Unpublish one instructor from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishInstructor(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: InstructorWhereUniqueInput!
    ): Instructor
    "Unpublish many Asset documents"
    unpublishManyAssets(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Locales to unpublish"
        locales: [Locale!],
        "Whether to unpublish the base document and default localization"
        unpublishBase: Boolean = true,
        "Identifies documents in each stage"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyAssetsConnection)")
    "Find many Asset documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        "Locales to unpublish"
        locales: [Locale!],
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Whether to unpublish the base document and default localization"
        unpublishBase: Boolean = true,
        "Identifies documents in draft stage"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Unpublish many ClassCategory documents"
    unpublishManyClassCategories(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: ClassCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyClassCategoriesConnection)")
    "Find many ClassCategory documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyClassCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: ClassCategoryManyWhereInput
    ): ClassCategoryConnection!
    "Unpublish many Class documents"
    unpublishManyClasses(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: ClassManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyClassesConnection)")
    "Find many Class documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyClassesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: ClassManyWhereInput
    ): ClassConnection!
    "Unpublish many FaqPage documents"
    unpublishManyFaqPages(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: FaqPageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyFaqPagesConnection)")
    "Find many FaqPage documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyFaqPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: FaqPageManyWhereInput
    ): FaqPageConnection!
    "Unpublish many Faq documents"
    unpublishManyFaqs(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: FaqManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyFaqsConnection)")
    "Find many Faq documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyFaqsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: FaqManyWhereInput
    ): FaqConnection!
    "Unpublish many Instructor documents"
    unpublishManyInstructors(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: InstructorManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyInstructorsConnection)")
    "Find many Instructor documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyInstructorsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: InstructorManyWhereInput
    ): InstructorConnection!
    "Unpublish many MembershipCategory documents"
    unpublishManyMembershipCategories(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: MembershipCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyMembershipCategoriesConnection)")
    "Find many MembershipCategory documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyMembershipCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: MembershipCategoryManyWhereInput
    ): MembershipCategoryConnection!
    "Unpublish many MembershipTier documents"
    unpublishManyMembershipTiers(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: MembershipTierManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyMembershipTiersConnection)")
    "Find many MembershipTier documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyMembershipTiersConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: MembershipTierManyWhereInput
    ): MembershipTierConnection!
    "Unpublish many Page documents"
    unpublishManyPages(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyPagesConnection)")
    "Find many Page documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyPagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: PageManyWhereInput
    ): PageConnection!
    "Unpublish many Policy documents"
    unpublishManyPolicies(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: PolicyManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyPoliciesConnection)")
    "Find many Policy documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyPoliciesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: PolicyManyWhereInput
    ): PolicyConnection!
    "Unpublish many TestCategory documents"
    unpublishManyTestCategories(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: TestCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyTestCategoriesConnection)")
    "Find many TestCategory documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyTestCategoriesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: TestCategoryManyWhereInput
    ): TestCategoryConnection!
    "Unpublish many WebsiteDefaultImage documents"
    unpublishManyWebsiteDefaultImages(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: WebsiteDefaultImageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (unpublishManyWebsiteDefaultImagesConnection)")
    "Find many WebsiteDefaultImage documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyWebsiteDefaultImagesConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: WebsiteDefaultImageManyWhereInput
    ): WebsiteDefaultImageConnection!
    "Unpublish one membershipCategory from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishMembershipCategory(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: MembershipCategoryWhereUniqueInput!
    ): MembershipCategory
    "Unpublish one membershipTier from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishMembershipTier(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: MembershipTierWhereUniqueInput!
    ): MembershipTier
    "Unpublish one page from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishPage(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: PageWhereUniqueInput!
    ): Page
    "Unpublish one policy from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishPolicy(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: PolicyWhereUniqueInput!
    ): Policy
    "Unpublish one testCategory from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishTestCategory(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: TestCategoryWhereUniqueInput!
    ): TestCategory
    "Unpublish one websiteDefaultImage from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishWebsiteDefaultImage(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: WebsiteDefaultImageWhereUniqueInput!
    ): WebsiteDefaultImage
    "Update one asset"
    updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
    "Update one class"
    updateClass(data: ClassUpdateInput!, where: ClassWhereUniqueInput!): Class
    "Update one classCategory"
    updateClassCategory(data: ClassCategoryUpdateInput!, where: ClassCategoryWhereUniqueInput!): ClassCategory
    "Update one faq"
    updateFaq(data: FaqUpdateInput!, where: FaqWhereUniqueInput!): Faq
    "Update one faqPage"
    updateFaqPage(data: FaqPageUpdateInput!, where: FaqPageWhereUniqueInput!): FaqPage
    "Update one instructor"
    updateInstructor(data: InstructorUpdateInput!, where: InstructorWhereUniqueInput!): Instructor
    "Update many assets"
    updateManyAssets(
        "Updates to document content"
        data: AssetUpdateManyInput!,
        "Documents to apply update on"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyAssetsConnection)")
    "Update many Asset documents"
    updateManyAssetsConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: AssetUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Update many classCategories"
    updateManyClassCategories(
        "Updates to document content"
        data: ClassCategoryUpdateManyInput!,
        "Documents to apply update on"
        where: ClassCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyClassCategoriesConnection)")
    "Update many ClassCategory documents"
    updateManyClassCategoriesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: ClassCategoryUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: ClassCategoryManyWhereInput
    ): ClassCategoryConnection!
    "Update many classes"
    updateManyClasses(
        "Updates to document content"
        data: ClassUpdateManyInput!,
        "Documents to apply update on"
        where: ClassManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyClassesConnection)")
    "Update many Class documents"
    updateManyClassesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: ClassUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: ClassManyWhereInput
    ): ClassConnection!
    "Update many faqPages"
    updateManyFaqPages(
        "Updates to document content"
        data: FaqPageUpdateManyInput!,
        "Documents to apply update on"
        where: FaqPageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyFaqPagesConnection)")
    "Update many FaqPage documents"
    updateManyFaqPagesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: FaqPageUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: FaqPageManyWhereInput
    ): FaqPageConnection!
    "Update many faqs"
    updateManyFaqs(
        "Updates to document content"
        data: FaqUpdateManyInput!,
        "Documents to apply update on"
        where: FaqManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyFaqsConnection)")
    "Update many Faq documents"
    updateManyFaqsConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: FaqUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: FaqManyWhereInput
    ): FaqConnection!
    "Update many instructors"
    updateManyInstructors(
        "Updates to document content"
        data: InstructorUpdateManyInput!,
        "Documents to apply update on"
        where: InstructorManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyInstructorsConnection)")
    "Update many Instructor documents"
    updateManyInstructorsConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: InstructorUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: InstructorManyWhereInput
    ): InstructorConnection!
    "Update many membershipCategories"
    updateManyMembershipCategories(
        "Updates to document content"
        data: MembershipCategoryUpdateManyInput!,
        "Documents to apply update on"
        where: MembershipCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyMembershipCategoriesConnection)")
    "Update many MembershipCategory documents"
    updateManyMembershipCategoriesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: MembershipCategoryUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: MembershipCategoryManyWhereInput
    ): MembershipCategoryConnection!
    "Update many membershipTiers"
    updateManyMembershipTiers(
        "Updates to document content"
        data: MembershipTierUpdateManyInput!,
        "Documents to apply update on"
        where: MembershipTierManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyMembershipTiersConnection)")
    "Update many MembershipTier documents"
    updateManyMembershipTiersConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: MembershipTierUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: MembershipTierManyWhereInput
    ): MembershipTierConnection!
    "Update many pages"
    updateManyPages(
        "Updates to document content"
        data: PageUpdateManyInput!,
        "Documents to apply update on"
        where: PageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyPagesConnection)")
    "Update many Page documents"
    updateManyPagesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: PageUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: PageManyWhereInput
    ): PageConnection!
    "Update many policies"
    updateManyPolicies(
        "Updates to document content"
        data: PolicyUpdateManyInput!,
        "Documents to apply update on"
        where: PolicyManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyPoliciesConnection)")
    "Update many Policy documents"
    updateManyPoliciesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: PolicyUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: PolicyManyWhereInput
    ): PolicyConnection!
    "Update many testCategories"
    updateManyTestCategories(
        "Updates to document content"
        data: TestCategoryUpdateManyInput!,
        "Documents to apply update on"
        where: TestCategoryManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyTestCategoriesConnection)")
    "Update many TestCategory documents"
    updateManyTestCategoriesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: TestCategoryUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: TestCategoryManyWhereInput
    ): TestCategoryConnection!
    "Update many websiteDefaultImages"
    updateManyWebsiteDefaultImages(
        "Updates to document content"
        data: WebsiteDefaultImageUpdateManyInput!,
        "Documents to apply update on"
        where: WebsiteDefaultImageManyWhereInput
    ): BatchPayload! @deprecated(reason : "Please use the new paginated many mutation (updateManyWebsiteDefaultImagesConnection)")
    "Update many WebsiteDefaultImage documents"
    updateManyWebsiteDefaultImagesConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: WebsiteDefaultImageUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: WebsiteDefaultImageManyWhereInput
    ): WebsiteDefaultImageConnection!
    "Update one membershipCategory"
    updateMembershipCategory(data: MembershipCategoryUpdateInput!, where: MembershipCategoryWhereUniqueInput!): MembershipCategory
    "Update one membershipTier"
    updateMembershipTier(data: MembershipTierUpdateInput!, where: MembershipTierWhereUniqueInput!): MembershipTier
    "Update one page"
    updatePage(data: PageUpdateInput!, where: PageWhereUniqueInput!): Page
    "Update one policy"
    updatePolicy(data: PolicyUpdateInput!, where: PolicyWhereUniqueInput!): Policy
    "Update one testCategory"
    updateTestCategory(data: TestCategoryUpdateInput!, where: TestCategoryWhereUniqueInput!): TestCategory
    "Update one websiteDefaultImage"
    updateWebsiteDefaultImage(data: WebsiteDefaultImageUpdateInput!, where: WebsiteDefaultImageWhereUniqueInput!): WebsiteDefaultImage
    "Upsert one asset"
    upsertAsset(upsert: AssetUpsertInput!, where: AssetWhereUniqueInput!): Asset
    "Upsert one class"
    upsertClass(upsert: ClassUpsertInput!, where: ClassWhereUniqueInput!): Class
    "Upsert one classCategory"
    upsertClassCategory(upsert: ClassCategoryUpsertInput!, where: ClassCategoryWhereUniqueInput!): ClassCategory
    "Upsert one faq"
    upsertFaq(upsert: FaqUpsertInput!, where: FaqWhereUniqueInput!): Faq
    "Upsert one faqPage"
    upsertFaqPage(upsert: FaqPageUpsertInput!, where: FaqPageWhereUniqueInput!): FaqPage
    "Upsert one instructor"
    upsertInstructor(upsert: InstructorUpsertInput!, where: InstructorWhereUniqueInput!): Instructor
    "Upsert one membershipCategory"
    upsertMembershipCategory(upsert: MembershipCategoryUpsertInput!, where: MembershipCategoryWhereUniqueInput!): MembershipCategory
    "Upsert one membershipTier"
    upsertMembershipTier(upsert: MembershipTierUpsertInput!, where: MembershipTierWhereUniqueInput!): MembershipTier
    "Upsert one page"
    upsertPage(upsert: PageUpsertInput!, where: PageWhereUniqueInput!): Page
    "Upsert one policy"
    upsertPolicy(upsert: PolicyUpsertInput!, where: PolicyWhereUniqueInput!): Policy
    "Upsert one testCategory"
    upsertTestCategory(upsert: TestCategoryUpsertInput!, where: TestCategoryWhereUniqueInput!): TestCategory
    "Upsert one websiteDefaultImage"
    upsertWebsiteDefaultImage(upsert: WebsiteDefaultImageUpsertInput!, where: WebsiteDefaultImageWhereUniqueInput!): WebsiteDefaultImage
}

"Top-level pages"
type Page implements Node {
    brandedHeader: String!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Page!]!
    headerBody: String
    "List of Page versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    "SEO meta description"
    metaDescription: String!
    pageEndpoint: String!
    pageTitle: String!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type PageConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [PageEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Page!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "Number of items in the current page."
    pageSize: Int
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"Business policies, i.e., Cancellations, Missing classes, etc."
type Policy implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Policy!]!
    "List of Policy versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    policyName: String!
    policyText: PolicyPolicyTextRichText
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type PolicyConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [PolicyEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PolicyEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Policy!
}

type PolicyPolicyTextRichText {
    "Returns HTMl representation"
    html: String!
    json: RichTextAST!
    "Returns Markdown representation"
    markdown: String!
    raw: RichTextAST! @deprecated(reason : "Please use the 'json' field")
    references: [PolicyPolicyTextRichTextEmbeddedTypes!]!
    "Returns plain-text contents of RichText"
    text: String!
}

type Query {
    "Retrieve a single asset"
    asset(
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: AssetWhereUniqueInput!
    ): Asset
    "Retrieve document version"
    assetVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple assets"
    assets(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): [Asset!]!
    "Retrieve multiple assets using the Relay connection interface"
    assetsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): AssetConnection!
    "Retrieve a single class"
    class(
        """

        Defines which locales should be returned.

        Note that `Class` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ClassWhereUniqueInput!
    ): Class
    "Retrieve multiple classCategories"
    classCategories(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ClassCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ClassCategoryOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ClassCategoryWhereInput
    ): [ClassCategory!]!
    "Retrieve multiple classCategories using the Relay connection interface"
    classCategoriesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ClassCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ClassCategoryOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ClassCategoryWhereInput
    ): ClassCategoryConnection!
    "Retrieve a single classCategory"
    classCategory(
        """

        Defines which locales should be returned.

        Note that `ClassCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ClassCategoryWhereUniqueInput!
    ): ClassCategory
    "Retrieve document version"
    classCategoryVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve document version"
    classVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple classes"
    classes(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Class` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ClassOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ClassWhereInput
    ): [Class!]!
    "Retrieve multiple classes using the Relay connection interface"
    classesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Class` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ClassOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ClassWhereInput
    ): ClassConnection!
    "Retrieve a single faq"
    faq(
        """

        Defines which locales should be returned.

        Note that `Faq` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: FaqWhereUniqueInput!
    ): Faq
    "Retrieve a single faqPage"
    faqPage(
        """

        Defines which locales should be returned.

        Note that `FaqPage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: FaqPageWhereUniqueInput!
    ): FaqPage
    "Retrieve document version"
    faqPageVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple faqPages"
    faqPages(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `FaqPage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: FaqPageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: FaqPageWhereInput
    ): [FaqPage!]!
    "Retrieve multiple faqPages using the Relay connection interface"
    faqPagesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `FaqPage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: FaqPageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: FaqPageWhereInput
    ): FaqPageConnection!
    "Retrieve document version"
    faqVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple faqs"
    faqs(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Faq` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: FaqOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: FaqWhereInput
    ): [Faq!]!
    "Retrieve multiple faqs using the Relay connection interface"
    faqsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Faq` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: FaqOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: FaqWhereInput
    ): FaqConnection!
    "Retrieve a single instructor"
    instructor(
        """

        Defines which locales should be returned.

        Note that `Instructor` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: InstructorWhereUniqueInput!
    ): Instructor
    "Retrieve document version"
    instructorVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple instructors"
    instructors(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Instructor` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: InstructorOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: InstructorWhereInput
    ): [Instructor!]!
    "Retrieve multiple instructors using the Relay connection interface"
    instructorsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Instructor` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: InstructorOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: InstructorWhereInput
    ): InstructorConnection!
    "Retrieve multiple membershipCategories"
    membershipCategories(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `MembershipCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: MembershipCategoryOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: MembershipCategoryWhereInput
    ): [MembershipCategory!]!
    "Retrieve multiple membershipCategories using the Relay connection interface"
    membershipCategoriesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `MembershipCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: MembershipCategoryOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: MembershipCategoryWhereInput
    ): MembershipCategoryConnection!
    "Retrieve a single membershipCategory"
    membershipCategory(
        """

        Defines which locales should be returned.

        Note that `MembershipCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: MembershipCategoryWhereUniqueInput!
    ): MembershipCategory
    "Retrieve document version"
    membershipCategoryVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve a single membershipTier"
    membershipTier(
        """

        Defines which locales should be returned.

        Note that `MembershipTier` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: MembershipTierWhereUniqueInput!
    ): MembershipTier
    "Retrieve document version"
    membershipTierVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple membershipTiers"
    membershipTiers(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `MembershipTier` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: MembershipTierOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: MembershipTierWhereInput
    ): [MembershipTier!]!
    "Retrieve multiple membershipTiers using the Relay connection interface"
    membershipTiersConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `MembershipTier` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: MembershipTierOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: MembershipTierWhereInput
    ): MembershipTierConnection!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!,
        """

        Defines which locales should be returned.

        Note that `Node` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED
    ): Node
    "Retrieve a single page"
    page(
        """

        Defines which locales should be returned.

        Note that `Page` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: PageWhereUniqueInput!
    ): Page
    "Retrieve document version"
    pageVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple pages"
    pages(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Page` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: PageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: PageWhereInput
    ): [Page!]!
    "Retrieve multiple pages using the Relay connection interface"
    pagesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Page` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: PageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: PageWhereInput
    ): PageConnection!
    "Retrieve multiple policies"
    policies(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Policy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: PolicyOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: PolicyWhereInput
    ): [Policy!]!
    "Retrieve multiple policies using the Relay connection interface"
    policiesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Policy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: PolicyOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: PolicyWhereInput
    ): PolicyConnection!
    "Retrieve a single policy"
    policy(
        """

        Defines which locales should be returned.

        Note that `Policy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: PolicyWhereUniqueInput!
    ): Policy
    "Retrieve document version"
    policyVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple testCategories"
    testCategories(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `TestCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: TestCategoryOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: TestCategoryWhereInput
    ): [TestCategory!]!
    "Retrieve multiple testCategories using the Relay connection interface"
    testCategoriesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `TestCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: TestCategoryOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: TestCategoryWhereInput
    ): TestCategoryConnection!
    "Retrieve a single testCategory"
    testCategory(
        """

        Defines which locales should be returned.

        Note that `TestCategory` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: TestCategoryWhereUniqueInput!
    ): TestCategory
    "Retrieve document version"
    testCategoryVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve a single user"
    user(
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: UserWhereUniqueInput!
    ): User
    "Retrieve multiple users"
    users(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: UserOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: UserWhereInput
    ): [User!]!
    "Retrieve multiple users using the Relay connection interface"
    usersConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: UserOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: UserWhereInput
    ): UserConnection!
    "Retrieve a single websiteDefaultImage"
    websiteDefaultImage(
        """

        Defines which locales should be returned.

        Note that `WebsiteDefaultImage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: WebsiteDefaultImageWhereUniqueInput!
    ): WebsiteDefaultImage
    "Retrieve document version"
    websiteDefaultImageVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple websiteDefaultImages"
    websiteDefaultImages(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `WebsiteDefaultImage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: WebsiteDefaultImageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: WebsiteDefaultImageWhereInput
    ): [WebsiteDefaultImage!]!
    "Retrieve multiple websiteDefaultImages using the Relay connection interface"
    websiteDefaultImagesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `WebsiteDefaultImage` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: WebsiteDefaultImageOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: WebsiteDefaultImageWhereInput
    ): WebsiteDefaultImageConnection!
}

"Representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
type RGBA {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

"Custom type representing a rich text value comprising of raw rich text ast, html, markdown and text values"
type RichText {
    "Returns HTMl representation"
    html: String!
    "Returns Markdown representation"
    markdown: String!
    "Returns AST representation"
    raw: RichTextAST!
    "Returns plain-text contents of RichText"
    text: String!
}

type TestCategory implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [TestCategory!]!
    "List of TestCategory versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    membershipTiers(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `membershipTiers` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: MembershipTierOrderByInput,
        skip: Int,
        where: MembershipTierWhereInput
    ): [MembershipTier!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type TestCategoryConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [TestCategoryEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TestCategoryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TestCategory!
}

"User system model"
type User implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [User!]!
    "The unique identifier"
    id: ID!
    "Flag to determine if user is active or not"
    isActive: Boolean!
    "User Kind. Can be either MEMBER, PAT or PUBLIC"
    kind: UserKind!
    "The username"
    name: String!
    "Profile Picture url"
    picture: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
}

"A connection to a list of items."
type UserConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [UserEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

type Version {
    createdAt: DateTime!
    id: ID!
    revision: Int!
    stage: Stage!
}

"Default images used on the website layout"
type WebsiteDefaultImage implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [WebsiteDefaultImage!]!
    "List of WebsiteDefaultImage versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    image(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `image` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Asset
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "System stage field"
    stage: Stage!
    title: String
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type WebsiteDefaultImageConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [WebsiteDefaultImageEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type WebsiteDefaultImageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: WebsiteDefaultImage!
}

enum AssetOrderByInput {
    altText_ASC
    altText_DESC
    createdAt_ASC
    createdAt_DESC
    fileName_ASC
    fileName_DESC
    handle_ASC
    handle_DESC
    height_ASC
    height_DESC
    id_ASC
    id_DESC
    mimeType_ASC
    mimeType_DESC
    publishedAt_ASC
    publishedAt_DESC
    size_ASC
    size_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
    width_ASC
    width_DESC
}

"Whether the button is filled in or just outlined"
enum ButtonVariant {
    contained
    outlined
}

enum ClassCategoryOrderByInput {
    categoryTitle_ASC
    categoryTitle_DESC
    createdAt_ASC
    createdAt_DESC
    description_ASC
    description_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum ClassOrderByInput {
    buttonText_ASC
    buttonText_DESC
    classDescriptionList_ASC
    classDescriptionList_DESC
    classInfoList_ASC
    classInfoList_DESC
    classLink_ASC
    classLink_DESC
    className_ASC
    className_DESC
    createdAt_ASC
    createdAt_DESC
    disableBookingButton_ASC
    disableBookingButton_DESC
    displayTitle_ASC
    displayTitle_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum Days {
    Friday
    Monday
    Saturday
    Sunday
    Thursday
    Tuesday
    Wednesday
}

enum DocumentFileTypes {
    doc
    docx
    html
    jpg
    odp
    ods
    odt
    pdf
    png
    ppt
    pptx
    svg
    txt
    webp
    xls
    xlsx
}

enum FaqOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    markdown_ASC
    markdown_DESC
    publishedAt_ASC
    publishedAt_DESC
    question_ASC
    question_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum FaqPageOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    pageTitle_ASC
    pageTitle_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum ImageFit {
    "Resizes the image to fit within the specified parameters without distorting, cropping, or changing the aspect ratio."
    clip
    "Resizes the image to fit the specified parameters exactly by removing any parts of the image that don't fit within the boundaries."
    crop
    "Resizes the image to fit within the parameters, but as opposed to 'fit:clip' will not scale the image if the image is smaller than the output size."
    max
    "Resizes the image to fit the specified parameters exactly by scaling the image to the desired size. The aspect ratio of the image is not respected and the image can be distorted using this method."
    scale
}

enum InstructorOrderByInput {
    createdAt_ASC
    createdAt_DESC
    defaultInstructor_ASC
    defaultInstructor_DESC
    firstName_ASC
    firstName_DESC
    id_ASC
    id_DESC
    isStaff_ASC
    isStaff_DESC
    lastName_ASC
    lastName_DESC
    publishedAt_ASC
    publishedAt_DESC
    staffTitle_ASC
    staffTitle_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"Locale system enumeration"
enum Locale {
    "System locale"
    en
}

enum MembershipCategoryOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"Term length of initial contract for memberships"
enum MembershipTerm {
    Membership
    Month
    Pass
}

enum MembershipTierCategory {
    Family
    Family_Memberships
    Individual
    Individual_Memberships
}

enum MembershipTierOrderByInput {
    buttonText_ASC
    buttonText_DESC
    buttonVariant_ASC
    buttonVariant_DESC
    createdAt_ASC
    createdAt_DESC
    description_ASC
    description_DESC
    id_ASC
    id_DESC
    inputValue_ASC
    inputValue_DESC
    price_ASC
    price_DESC
    publishedAt_ASC
    publishedAt_DESC
    term_ASC
    term_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum PageOrderByInput {
    brandedHeader_ASC
    brandedHeader_DESC
    createdAt_ASC
    createdAt_DESC
    headerBody_ASC
    headerBody_DESC
    id_ASC
    id_DESC
    metaDescription_ASC
    metaDescription_DESC
    pageEndpoint_ASC
    pageEndpoint_DESC
    pageTitle_ASC
    pageTitle_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum PolicyOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    policyName_ASC
    policyName_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"Stage system enumeration"
enum Stage {
    "The Draft is the default stage for all your content."
    DRAFT
    "The Published stage is where you can publish your content to."
    PUBLISHED
}

enum SystemDateTimeFieldVariation {
    BASE
    COMBINED
    LOCALIZATION
}

enum TestCategoryOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"System User Kind"
enum UserKind {
    MEMBER
    PAT
    PUBLIC
    WEBHOOK
}

enum UserOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    isActive_ASC
    isActive_DESC
    kind_ASC
    kind_DESC
    name_ASC
    name_DESC
    picture_ASC
    picture_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum WebsiteDefaultImageOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum _FilterKind {
    AND
    NOT
    OR
    contains
    contains_all
    contains_none
    contains_some
    ends_with
    eq
    eq_not
    gt
    gte
    in
    lt
    lte
    not_contains
    not_ends_with
    not_in
    not_starts_with
    relational_every
    relational_none
    relational_single
    relational_some
    search
    starts_with
}

enum _MutationInputFieldKind {
    enum
    relation
    richText
    richTextWithEmbeds
    scalar
    union
    virtual
}

enum _MutationKind {
    create
    delete
    deleteMany
    publish
    publishMany
    unpublish
    unpublishMany
    update
    updateMany
    upsert
}

enum _OrderDirection {
    asc
    desc
}

enum _RelationInputCardinality {
    many
    one
}

enum _RelationInputKind {
    create
    update
}

enum _RelationKind {
    regular
    union
}

enum _SystemDateTimeFieldVariation {
    base
    combined
    localization
}

input AssetConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: AssetWhereUniqueInput!
}

input AssetCreateInput {
    altText: String
    createdAt: DateTime
    fileName: String!
    handle: String!
    height: Float
    imageWebsiteDefaultImage: WebsiteDefaultImageCreateManyInlineInput
    instructorHeadshotImage: InstructorCreateManyInlineInput
    "Inline mutations for managing document localizations excluding the default locale"
    localizations: AssetCreateLocalizationsInput
    mimeType: String
    size: Float
    staffPictureInstructor: InstructorCreateManyInlineInput
    title: String
    updatedAt: DateTime
    width: Float
}

input AssetCreateLocalizationDataInput {
    createdAt: DateTime
    fileName: String!
    handle: String!
    height: Float
    mimeType: String
    size: Float
    updatedAt: DateTime
    width: Float
}

input AssetCreateLocalizationInput {
    "Localization input"
    data: AssetCreateLocalizationDataInput!
    locale: Locale!
}

input AssetCreateLocalizationsInput {
    "Create localizations for the newly-created document"
    create: [AssetCreateLocalizationInput!]
}

input AssetCreateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetWhereUniqueInput!]
    "Create and connect multiple existing Asset documents"
    create: [AssetCreateInput!]
}

input AssetCreateOneInlineInput {
    "Connect one existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
}

"Identifies documents"
input AssetManyWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    altText: String
    "All values containing the given string."
    altText_contains: String
    "All values ending with the given string."
    altText_ends_with: String
    "All values that are contained in given list."
    altText_in: [String!]
    "All values that are not equal to given value."
    altText_not: String
    "All values not containing the given string."
    altText_not_contains: String
    "All values not ending with the given string"
    altText_not_ends_with: String
    "All values that are not contained in given list."
    altText_not_in: [String!]
    "All values not starting with the given string."
    altText_not_starts_with: String
    "All values starting with the given string."
    altText_starts_with: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    imageWebsiteDefaultImage_every: WebsiteDefaultImageWhereInput
    imageWebsiteDefaultImage_none: WebsiteDefaultImageWhereInput
    imageWebsiteDefaultImage_some: WebsiteDefaultImageWhereInput
    instructorHeadshotImage_every: InstructorWhereInput
    instructorHeadshotImage_none: InstructorWhereInput
    instructorHeadshotImage_some: InstructorWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    staffPictureInstructor_every: InstructorWhereInput
    staffPictureInstructor_none: InstructorWhereInput
    staffPictureInstructor_some: InstructorWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"Transformations for Assets"
input AssetTransformationInput {
    document: DocumentTransformationInput
    image: ImageTransformationInput
    "Pass true if you want to validate the passed transformation parameters"
    validateOptions: Boolean = false
}

input AssetUpdateInput {
    altText: String
    fileName: String
    handle: String
    height: Float
    imageWebsiteDefaultImage: WebsiteDefaultImageUpdateManyInlineInput
    instructorHeadshotImage: InstructorUpdateManyInlineInput
    "Manage document localizations"
    localizations: AssetUpdateLocalizationsInput
    mimeType: String
    size: Float
    staffPictureInstructor: InstructorUpdateManyInlineInput
    title: String
    width: Float
}

input AssetUpdateLocalizationDataInput {
    fileName: String
    handle: String
    height: Float
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateLocalizationInput {
    data: AssetUpdateLocalizationDataInput!
    locale: Locale!
}

input AssetUpdateLocalizationsInput {
    "Localizations to create"
    create: [AssetCreateLocalizationInput!]
    "Localizations to delete"
    delete: [Locale!]
    "Localizations to update"
    update: [AssetUpdateLocalizationInput!]
    upsert: [AssetUpsertLocalizationInput!]
}

input AssetUpdateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetConnectInput!]
    "Create and connect multiple Asset documents"
    create: [AssetCreateInput!]
    "Delete multiple Asset documents"
    delete: [AssetWhereUniqueInput!]
    "Disconnect multiple Asset documents"
    disconnect: [AssetWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Asset documents"
    set: [AssetWhereUniqueInput!]
    "Update multiple Asset documents"
    update: [AssetUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Asset documents"
    upsert: [AssetUpsertWithNestedWhereUniqueInput!]
}

input AssetUpdateManyInput {
    altText: String
    fileName: String
    height: Float
    "Optional updates to localizations"
    localizations: AssetUpdateManyLocalizationsInput
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateManyLocalizationDataInput {
    fileName: String
    height: Float
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateManyLocalizationInput {
    data: AssetUpdateManyLocalizationDataInput!
    locale: Locale!
}

input AssetUpdateManyLocalizationsInput {
    "Localizations to update"
    update: [AssetUpdateManyLocalizationInput!]
}

input AssetUpdateManyWithNestedWhereInput {
    "Update many input"
    data: AssetUpdateManyInput!
    "Document search"
    where: AssetWhereInput!
}

input AssetUpdateOneInlineInput {
    "Connect existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
    "Delete currently connected Asset document"
    delete: Boolean
    "Disconnect currently connected Asset document"
    disconnect: Boolean
    "Update single Asset document"
    update: AssetUpdateWithNestedWhereUniqueInput
    "Upsert single Asset document"
    upsert: AssetUpsertWithNestedWhereUniqueInput
}

input AssetUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: AssetUpdateInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

input AssetUpsertInput {
    "Create document if it didn't exist"
    create: AssetCreateInput!
    "Update document if it exists"
    update: AssetUpdateInput!
}

input AssetUpsertLocalizationInput {
    create: AssetCreateLocalizationDataInput!
    locale: Locale!
    update: AssetUpdateLocalizationDataInput!
}

input AssetUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: AssetUpsertInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

"Identifies documents"
input AssetWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    altText: String
    "All values containing the given string."
    altText_contains: String
    "All values ending with the given string."
    altText_ends_with: String
    "All values that are contained in given list."
    altText_in: [String!]
    "All values that are not equal to given value."
    altText_not: String
    "All values not containing the given string."
    altText_not_contains: String
    "All values not ending with the given string"
    altText_not_ends_with: String
    "All values that are not contained in given list."
    altText_not_in: [String!]
    "All values not starting with the given string."
    altText_not_starts_with: String
    "All values starting with the given string."
    altText_starts_with: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    fileName: String
    "All values containing the given string."
    fileName_contains: String
    "All values ending with the given string."
    fileName_ends_with: String
    "All values that are contained in given list."
    fileName_in: [String!]
    "All values that are not equal to given value."
    fileName_not: String
    "All values not containing the given string."
    fileName_not_contains: String
    "All values not ending with the given string"
    fileName_not_ends_with: String
    "All values that are not contained in given list."
    fileName_not_in: [String!]
    "All values not starting with the given string."
    fileName_not_starts_with: String
    "All values starting with the given string."
    fileName_starts_with: String
    handle: String
    "All values containing the given string."
    handle_contains: String
    "All values ending with the given string."
    handle_ends_with: String
    "All values that are contained in given list."
    handle_in: [String!]
    "All values that are not equal to given value."
    handle_not: String
    "All values not containing the given string."
    handle_not_contains: String
    "All values not ending with the given string"
    handle_not_ends_with: String
    "All values that are not contained in given list."
    handle_not_in: [String!]
    "All values not starting with the given string."
    handle_not_starts_with: String
    "All values starting with the given string."
    handle_starts_with: String
    height: Float
    "All values greater than the given value."
    height_gt: Float
    "All values greater than or equal the given value."
    height_gte: Float
    "All values that are contained in given list."
    height_in: [Float!]
    "All values less than the given value."
    height_lt: Float
    "All values less than or equal the given value."
    height_lte: Float
    "All values that are not equal to given value."
    height_not: Float
    "All values that are not contained in given list."
    height_not_in: [Float!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    imageWebsiteDefaultImage_every: WebsiteDefaultImageWhereInput
    imageWebsiteDefaultImage_none: WebsiteDefaultImageWhereInput
    imageWebsiteDefaultImage_some: WebsiteDefaultImageWhereInput
    instructorHeadshotImage_every: InstructorWhereInput
    instructorHeadshotImage_none: InstructorWhereInput
    instructorHeadshotImage_some: InstructorWhereInput
    mimeType: String
    "All values containing the given string."
    mimeType_contains: String
    "All values ending with the given string."
    mimeType_ends_with: String
    "All values that are contained in given list."
    mimeType_in: [String!]
    "All values that are not equal to given value."
    mimeType_not: String
    "All values not containing the given string."
    mimeType_not_contains: String
    "All values not ending with the given string"
    mimeType_not_ends_with: String
    "All values that are not contained in given list."
    mimeType_not_in: [String!]
    "All values not starting with the given string."
    mimeType_not_starts_with: String
    "All values starting with the given string."
    mimeType_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    size: Float
    "All values greater than the given value."
    size_gt: Float
    "All values greater than or equal the given value."
    size_gte: Float
    "All values that are contained in given list."
    size_in: [Float!]
    "All values less than the given value."
    size_lt: Float
    "All values less than or equal the given value."
    size_lte: Float
    "All values that are not equal to given value."
    size_not: Float
    "All values that are not contained in given list."
    size_not_in: [Float!]
    staffPictureInstructor_every: InstructorWhereInput
    staffPictureInstructor_none: InstructorWhereInput
    staffPictureInstructor_some: InstructorWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
    width: Float
    "All values greater than the given value."
    width_gt: Float
    "All values greater than or equal the given value."
    width_gte: Float
    "All values that are contained in given list."
    width_in: [Float!]
    "All values less than the given value."
    width_lt: Float
    "All values less than or equal the given value."
    width_lte: Float
    "All values that are not equal to given value."
    width_not: Float
    "All values that are not contained in given list."
    width_not_in: [Float!]
}

"References Asset record uniquely"
input AssetWhereUniqueInput {
    id: ID
    title: String
}

input ClassCategoryConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ClassCategoryWhereUniqueInput!
}

input ClassCategoryCreateInput {
    categoryTitle: String!
    classes: ClassCreateManyInlineInput
    createdAt: DateTime
    description: String
    updatedAt: DateTime
}

input ClassCategoryCreateManyInlineInput {
    "Connect multiple existing ClassCategory documents"
    connect: [ClassCategoryWhereUniqueInput!]
    "Create and connect multiple existing ClassCategory documents"
    create: [ClassCategoryCreateInput!]
}

input ClassCategoryCreateOneInlineInput {
    "Connect one existing ClassCategory document"
    connect: ClassCategoryWhereUniqueInput
    "Create and connect one ClassCategory document"
    create: ClassCategoryCreateInput
}

"Identifies documents"
input ClassCategoryManyWhereInput {
    "Logical AND on all given filters."
    AND: [ClassCategoryWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ClassCategoryWhereInput!]
    "Logical OR on all given filters."
    OR: [ClassCategoryWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    categoryTitle: String
    "All values containing the given string."
    categoryTitle_contains: String
    "All values ending with the given string."
    categoryTitle_ends_with: String
    "All values that are contained in given list."
    categoryTitle_in: [String!]
    "All values that are not equal to given value."
    categoryTitle_not: String
    "All values not containing the given string."
    categoryTitle_not_contains: String
    "All values not ending with the given string"
    categoryTitle_not_ends_with: String
    "All values that are not contained in given list."
    categoryTitle_not_in: [String!]
    "All values not starting with the given string."
    categoryTitle_not_starts_with: String
    "All values starting with the given string."
    categoryTitle_starts_with: String
    classes_every: ClassWhereInput
    classes_none: ClassWhereInput
    classes_some: ClassWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input ClassCategoryUpdateInput {
    categoryTitle: String
    classes: ClassUpdateManyInlineInput
    description: String
}

input ClassCategoryUpdateManyInlineInput {
    "Connect multiple existing ClassCategory documents"
    connect: [ClassCategoryConnectInput!]
    "Create and connect multiple ClassCategory documents"
    create: [ClassCategoryCreateInput!]
    "Delete multiple ClassCategory documents"
    delete: [ClassCategoryWhereUniqueInput!]
    "Disconnect multiple ClassCategory documents"
    disconnect: [ClassCategoryWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ClassCategory documents"
    set: [ClassCategoryWhereUniqueInput!]
    "Update multiple ClassCategory documents"
    update: [ClassCategoryUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ClassCategory documents"
    upsert: [ClassCategoryUpsertWithNestedWhereUniqueInput!]
}

input ClassCategoryUpdateManyInput {
    description: String
}

input ClassCategoryUpdateManyWithNestedWhereInput {
    "Update many input"
    data: ClassCategoryUpdateManyInput!
    "Document search"
    where: ClassCategoryWhereInput!
}

input ClassCategoryUpdateOneInlineInput {
    "Connect existing ClassCategory document"
    connect: ClassCategoryWhereUniqueInput
    "Create and connect one ClassCategory document"
    create: ClassCategoryCreateInput
    "Delete currently connected ClassCategory document"
    delete: Boolean
    "Disconnect currently connected ClassCategory document"
    disconnect: Boolean
    "Update single ClassCategory document"
    update: ClassCategoryUpdateWithNestedWhereUniqueInput
    "Upsert single ClassCategory document"
    upsert: ClassCategoryUpsertWithNestedWhereUniqueInput
}

input ClassCategoryUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ClassCategoryUpdateInput!
    "Unique document search"
    where: ClassCategoryWhereUniqueInput!
}

input ClassCategoryUpsertInput {
    "Create document if it didn't exist"
    create: ClassCategoryCreateInput!
    "Update document if it exists"
    update: ClassCategoryUpdateInput!
}

input ClassCategoryUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ClassCategoryUpsertInput!
    "Unique document search"
    where: ClassCategoryWhereUniqueInput!
}

"Identifies documents"
input ClassCategoryWhereInput {
    "Logical AND on all given filters."
    AND: [ClassCategoryWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ClassCategoryWhereInput!]
    "Logical OR on all given filters."
    OR: [ClassCategoryWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    categoryTitle: String
    "All values containing the given string."
    categoryTitle_contains: String
    "All values ending with the given string."
    categoryTitle_ends_with: String
    "All values that are contained in given list."
    categoryTitle_in: [String!]
    "All values that are not equal to given value."
    categoryTitle_not: String
    "All values not containing the given string."
    categoryTitle_not_contains: String
    "All values not ending with the given string"
    categoryTitle_not_ends_with: String
    "All values that are not contained in given list."
    categoryTitle_not_in: [String!]
    "All values not starting with the given string."
    categoryTitle_not_starts_with: String
    "All values starting with the given string."
    categoryTitle_starts_with: String
    classes_every: ClassWhereInput
    classes_none: ClassWhereInput
    classes_some: ClassWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String!]
    "All values that are not equal to given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String!]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References ClassCategory record uniquely"
input ClassCategoryWhereUniqueInput {
    categoryTitle: String
    id: ID
}

input ClassConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ClassWhereUniqueInput!
}

input ClassCreateInput {
    buttonText: String!
    classCategory: ClassCategoryCreateOneInlineInput
    classDescriptionList: [String!]!
    classInfoList: [String!]
    classLink: String
    className: String!
    createdAt: DateTime
    disableBookingButton: Boolean!
    displayTitle: String
    instructor: InstructorCreateOneInlineInput
    updatedAt: DateTime
}

input ClassCreateManyInlineInput {
    "Connect multiple existing Class documents"
    connect: [ClassWhereUniqueInput!]
    "Create and connect multiple existing Class documents"
    create: [ClassCreateInput!]
}

input ClassCreateOneInlineInput {
    "Connect one existing Class document"
    connect: ClassWhereUniqueInput
    "Create and connect one Class document"
    create: ClassCreateInput
}

"Identifies documents"
input ClassManyWhereInput {
    "Logical AND on all given filters."
    AND: [ClassWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ClassWhereInput!]
    "Logical OR on all given filters."
    OR: [ClassWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    buttonText: String
    "All values containing the given string."
    buttonText_contains: String
    "All values ending with the given string."
    buttonText_ends_with: String
    "All values that are contained in given list."
    buttonText_in: [String!]
    "All values that are not equal to given value."
    buttonText_not: String
    "All values not containing the given string."
    buttonText_not_contains: String
    "All values not ending with the given string"
    buttonText_not_ends_with: String
    "All values that are not contained in given list."
    buttonText_not_in: [String!]
    "All values not starting with the given string."
    buttonText_not_starts_with: String
    "All values starting with the given string."
    buttonText_starts_with: String
    classCategory: ClassCategoryWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    classDescriptionList: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    classDescriptionList_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    classDescriptionList_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    classDescriptionList_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    classDescriptionList_not: [String!]
    "Matches if the field array contains *all* items provided to the filter and order does match"
    classInfoList: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    classInfoList_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    classInfoList_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    classInfoList_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    classInfoList_not: [String!]
    classLink: String
    "All values containing the given string."
    classLink_contains: String
    "All values ending with the given string."
    classLink_ends_with: String
    "All values that are contained in given list."
    classLink_in: [String!]
    "All values that are not equal to given value."
    classLink_not: String
    "All values not containing the given string."
    classLink_not_contains: String
    "All values not ending with the given string"
    classLink_not_ends_with: String
    "All values that are not contained in given list."
    classLink_not_in: [String!]
    "All values not starting with the given string."
    classLink_not_starts_with: String
    "All values starting with the given string."
    classLink_starts_with: String
    className: String
    "All values containing the given string."
    className_contains: String
    "All values ending with the given string."
    className_ends_with: String
    "All values that are contained in given list."
    className_in: [String!]
    "All values that are not equal to given value."
    className_not: String
    "All values not containing the given string."
    className_not_contains: String
    "All values not ending with the given string"
    className_not_ends_with: String
    "All values that are not contained in given list."
    className_not_in: [String!]
    "All values not starting with the given string."
    className_not_starts_with: String
    "All values starting with the given string."
    className_starts_with: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    disableBookingButton: Boolean
    "All values that are not equal to given value."
    disableBookingButton_not: Boolean
    displayTitle: String
    "All values containing the given string."
    displayTitle_contains: String
    "All values ending with the given string."
    displayTitle_ends_with: String
    "All values that are contained in given list."
    displayTitle_in: [String!]
    "All values that are not equal to given value."
    displayTitle_not: String
    "All values not containing the given string."
    displayTitle_not_contains: String
    "All values not ending with the given string"
    displayTitle_not_ends_with: String
    "All values that are not contained in given list."
    displayTitle_not_in: [String!]
    "All values not starting with the given string."
    displayTitle_not_starts_with: String
    "All values starting with the given string."
    displayTitle_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    instructor: InstructorWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input ClassUpdateInput {
    buttonText: String
    classCategory: ClassCategoryUpdateOneInlineInput
    classDescriptionList: [String!]
    classInfoList: [String!]
    classLink: String
    className: String
    disableBookingButton: Boolean
    displayTitle: String
    instructor: InstructorUpdateOneInlineInput
}

input ClassUpdateManyInlineInput {
    "Connect multiple existing Class documents"
    connect: [ClassConnectInput!]
    "Create and connect multiple Class documents"
    create: [ClassCreateInput!]
    "Delete multiple Class documents"
    delete: [ClassWhereUniqueInput!]
    "Disconnect multiple Class documents"
    disconnect: [ClassWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Class documents"
    set: [ClassWhereUniqueInput!]
    "Update multiple Class documents"
    update: [ClassUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Class documents"
    upsert: [ClassUpsertWithNestedWhereUniqueInput!]
}

input ClassUpdateManyInput {
    buttonText: String
    classDescriptionList: [String!]
    classInfoList: [String!]
    classLink: String
    disableBookingButton: Boolean
    displayTitle: String
}

input ClassUpdateManyWithNestedWhereInput {
    "Update many input"
    data: ClassUpdateManyInput!
    "Document search"
    where: ClassWhereInput!
}

input ClassUpdateOneInlineInput {
    "Connect existing Class document"
    connect: ClassWhereUniqueInput
    "Create and connect one Class document"
    create: ClassCreateInput
    "Delete currently connected Class document"
    delete: Boolean
    "Disconnect currently connected Class document"
    disconnect: Boolean
    "Update single Class document"
    update: ClassUpdateWithNestedWhereUniqueInput
    "Upsert single Class document"
    upsert: ClassUpsertWithNestedWhereUniqueInput
}

input ClassUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ClassUpdateInput!
    "Unique document search"
    where: ClassWhereUniqueInput!
}

input ClassUpsertInput {
    "Create document if it didn't exist"
    create: ClassCreateInput!
    "Update document if it exists"
    update: ClassUpdateInput!
}

input ClassUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ClassUpsertInput!
    "Unique document search"
    where: ClassWhereUniqueInput!
}

"Identifies documents"
input ClassWhereInput {
    "Logical AND on all given filters."
    AND: [ClassWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ClassWhereInput!]
    "Logical OR on all given filters."
    OR: [ClassWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    buttonText: String
    "All values containing the given string."
    buttonText_contains: String
    "All values ending with the given string."
    buttonText_ends_with: String
    "All values that are contained in given list."
    buttonText_in: [String!]
    "All values that are not equal to given value."
    buttonText_not: String
    "All values not containing the given string."
    buttonText_not_contains: String
    "All values not ending with the given string"
    buttonText_not_ends_with: String
    "All values that are not contained in given list."
    buttonText_not_in: [String!]
    "All values not starting with the given string."
    buttonText_not_starts_with: String
    "All values starting with the given string."
    buttonText_starts_with: String
    classCategory: ClassCategoryWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    classDescriptionList: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    classDescriptionList_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    classDescriptionList_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    classDescriptionList_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    classDescriptionList_not: [String!]
    "Matches if the field array contains *all* items provided to the filter and order does match"
    classInfoList: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    classInfoList_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    classInfoList_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    classInfoList_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    classInfoList_not: [String!]
    classLink: String
    "All values containing the given string."
    classLink_contains: String
    "All values ending with the given string."
    classLink_ends_with: String
    "All values that are contained in given list."
    classLink_in: [String!]
    "All values that are not equal to given value."
    classLink_not: String
    "All values not containing the given string."
    classLink_not_contains: String
    "All values not ending with the given string"
    classLink_not_ends_with: String
    "All values that are not contained in given list."
    classLink_not_in: [String!]
    "All values not starting with the given string."
    classLink_not_starts_with: String
    "All values starting with the given string."
    classLink_starts_with: String
    className: String
    "All values containing the given string."
    className_contains: String
    "All values ending with the given string."
    className_ends_with: String
    "All values that are contained in given list."
    className_in: [String!]
    "All values that are not equal to given value."
    className_not: String
    "All values not containing the given string."
    className_not_contains: String
    "All values not ending with the given string"
    className_not_ends_with: String
    "All values that are not contained in given list."
    className_not_in: [String!]
    "All values not starting with the given string."
    className_not_starts_with: String
    "All values starting with the given string."
    className_starts_with: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    disableBookingButton: Boolean
    "All values that are not equal to given value."
    disableBookingButton_not: Boolean
    displayTitle: String
    "All values containing the given string."
    displayTitle_contains: String
    "All values ending with the given string."
    displayTitle_ends_with: String
    "All values that are contained in given list."
    displayTitle_in: [String!]
    "All values that are not equal to given value."
    displayTitle_not: String
    "All values not containing the given string."
    displayTitle_not_contains: String
    "All values not ending with the given string"
    displayTitle_not_ends_with: String
    "All values that are not contained in given list."
    displayTitle_not_in: [String!]
    "All values not starting with the given string."
    displayTitle_not_starts_with: String
    "All values starting with the given string."
    displayTitle_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    instructor: InstructorWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Class record uniquely"
input ClassWhereUniqueInput {
    className: String
    id: ID
}

"Accepts either HEX or RGBA color value. At least one of hex or rgba value should be passed. If both are passed RGBA is used."
input ColorInput {
    hex: Hex
    rgba: RGBAInput
}

input ConnectPositionInput {
    "Connect document after specified document"
    after: ID
    "Connect document before specified document"
    before: ID
    "Connect document at last position"
    end: Boolean
    "Connect document at first position"
    start: Boolean
}

input DocumentOutputInput {
    """

    Transforms a document into a desired file type.
    See this matrix for format support:

    PDF:    jpg, odp, ods, odt, png, svg, txt, and webp
    DOC:    docx, html, jpg, odt, pdf, png, svg, txt, and webp
    DOCX:    doc, html, jpg, odt, pdf, png, svg, txt, and webp
    ODT:    doc, docx, html, jpg, pdf, png, svg, txt, and webp
    XLS:    jpg, pdf, ods, png, svg, xlsx, and webp
    XLSX:    jpg, pdf, ods, png, svg, xls, and webp
    ODS:    jpg, pdf, png, xls, svg, xlsx, and webp
    PPT:    jpg, odp, pdf, png, svg, pptx, and webp
    PPTX:    jpg, odp, pdf, png, svg, ppt, and webp
    ODP:    jpg, pdf, png, ppt, svg, pptx, and webp
    BMP:    jpg, odp, ods, odt, pdf, png, svg, and webp
    GIF:    jpg, odp, ods, odt, pdf, png, svg, and webp
    JPG:    jpg, odp, ods, odt, pdf, png, svg, and webp
    PNG:    jpg, odp, ods, odt, pdf, png, svg, and webp
    WEBP:    jpg, odp, ods, odt, pdf, png, svg, and webp
    TIFF:    jpg, odp, ods, odt, pdf, png, svg, and webp
    AI:        jpg, odp, ods, odt, pdf, png, svg, and webp
    PSD:    jpg, odp, ods, odt, pdf, png, svg, and webp
    SVG:    jpg, odp, ods, odt, pdf, png, and webp
    HTML:    jpg, odt, pdf, svg, txt, and webp
    TXT:    jpg, html, odt, pdf, svg, and webp
    """
    format: DocumentFileTypes
}

"Transformations for Documents"
input DocumentTransformationInput {
    "Changes the output for the file."
    output: DocumentOutputInput
}

input FaqConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: FaqWhereUniqueInput!
}

input FaqCreateInput {
    answer: RichTextAST!
    createdAt: DateTime
    faqPage: FaqPageCreateManyInlineInput
    markdown: String
    question: String!
    updatedAt: DateTime
}

input FaqCreateManyInlineInput {
    "Connect multiple existing Faq documents"
    connect: [FaqWhereUniqueInput!]
    "Create and connect multiple existing Faq documents"
    create: [FaqCreateInput!]
}

input FaqCreateOneInlineInput {
    "Connect one existing Faq document"
    connect: FaqWhereUniqueInput
    "Create and connect one Faq document"
    create: FaqCreateInput
}

"Identifies documents"
input FaqManyWhereInput {
    "Logical AND on all given filters."
    AND: [FaqWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [FaqWhereInput!]
    "Logical OR on all given filters."
    OR: [FaqWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    faqPage_every: FaqPageWhereInput
    faqPage_none: FaqPageWhereInput
    faqPage_some: FaqPageWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    markdown: String
    "All values containing the given string."
    markdown_contains: String
    "All values ending with the given string."
    markdown_ends_with: String
    "All values that are contained in given list."
    markdown_in: [String!]
    "All values that are not equal to given value."
    markdown_not: String
    "All values not containing the given string."
    markdown_not_contains: String
    "All values not ending with the given string"
    markdown_not_ends_with: String
    "All values that are not contained in given list."
    markdown_not_in: [String!]
    "All values not starting with the given string."
    markdown_not_starts_with: String
    "All values starting with the given string."
    markdown_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    question: String
    "All values containing the given string."
    question_contains: String
    "All values ending with the given string."
    question_ends_with: String
    "All values that are contained in given list."
    question_in: [String!]
    "All values that are not equal to given value."
    question_not: String
    "All values not containing the given string."
    question_not_contains: String
    "All values not ending with the given string"
    question_not_ends_with: String
    "All values that are not contained in given list."
    question_not_in: [String!]
    "All values not starting with the given string."
    question_not_starts_with: String
    "All values starting with the given string."
    question_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input FaqPageConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: FaqPageWhereUniqueInput!
}

input FaqPageCreateInput {
    createdAt: DateTime
    listOfFaQs: FaqCreateManyInlineInput
    pageTitle: String!
    updatedAt: DateTime
}

input FaqPageCreateManyInlineInput {
    "Connect multiple existing FaqPage documents"
    connect: [FaqPageWhereUniqueInput!]
    "Create and connect multiple existing FaqPage documents"
    create: [FaqPageCreateInput!]
}

input FaqPageCreateOneInlineInput {
    "Connect one existing FaqPage document"
    connect: FaqPageWhereUniqueInput
    "Create and connect one FaqPage document"
    create: FaqPageCreateInput
}

"Identifies documents"
input FaqPageManyWhereInput {
    "Logical AND on all given filters."
    AND: [FaqPageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [FaqPageWhereInput!]
    "Logical OR on all given filters."
    OR: [FaqPageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    listOfFaQs_every: FaqWhereInput
    listOfFaQs_none: FaqWhereInput
    listOfFaQs_some: FaqWhereInput
    pageTitle: String
    "All values containing the given string."
    pageTitle_contains: String
    "All values ending with the given string."
    pageTitle_ends_with: String
    "All values that are contained in given list."
    pageTitle_in: [String!]
    "All values that are not equal to given value."
    pageTitle_not: String
    "All values not containing the given string."
    pageTitle_not_contains: String
    "All values not ending with the given string"
    pageTitle_not_ends_with: String
    "All values that are not contained in given list."
    pageTitle_not_in: [String!]
    "All values not starting with the given string."
    pageTitle_not_starts_with: String
    "All values starting with the given string."
    pageTitle_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input FaqPageUpdateInput {
    listOfFaQs: FaqUpdateManyInlineInput
    pageTitle: String
}

input FaqPageUpdateManyInlineInput {
    "Connect multiple existing FaqPage documents"
    connect: [FaqPageConnectInput!]
    "Create and connect multiple FaqPage documents"
    create: [FaqPageCreateInput!]
    "Delete multiple FaqPage documents"
    delete: [FaqPageWhereUniqueInput!]
    "Disconnect multiple FaqPage documents"
    disconnect: [FaqPageWhereUniqueInput!]
    "Override currently-connected documents with multiple existing FaqPage documents"
    set: [FaqPageWhereUniqueInput!]
    "Update multiple FaqPage documents"
    update: [FaqPageUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple FaqPage documents"
    upsert: [FaqPageUpsertWithNestedWhereUniqueInput!]
}

input FaqPageUpdateManyInput {
    "No fields in updateMany data input"
    _: String
}

input FaqPageUpdateManyWithNestedWhereInput {
    "Update many input"
    data: FaqPageUpdateManyInput!
    "Document search"
    where: FaqPageWhereInput!
}

input FaqPageUpdateOneInlineInput {
    "Connect existing FaqPage document"
    connect: FaqPageWhereUniqueInput
    "Create and connect one FaqPage document"
    create: FaqPageCreateInput
    "Delete currently connected FaqPage document"
    delete: Boolean
    "Disconnect currently connected FaqPage document"
    disconnect: Boolean
    "Update single FaqPage document"
    update: FaqPageUpdateWithNestedWhereUniqueInput
    "Upsert single FaqPage document"
    upsert: FaqPageUpsertWithNestedWhereUniqueInput
}

input FaqPageUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: FaqPageUpdateInput!
    "Unique document search"
    where: FaqPageWhereUniqueInput!
}

input FaqPageUpsertInput {
    "Create document if it didn't exist"
    create: FaqPageCreateInput!
    "Update document if it exists"
    update: FaqPageUpdateInput!
}

input FaqPageUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: FaqPageUpsertInput!
    "Unique document search"
    where: FaqPageWhereUniqueInput!
}

"Identifies documents"
input FaqPageWhereInput {
    "Logical AND on all given filters."
    AND: [FaqPageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [FaqPageWhereInput!]
    "Logical OR on all given filters."
    OR: [FaqPageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    listOfFaQs_every: FaqWhereInput
    listOfFaQs_none: FaqWhereInput
    listOfFaQs_some: FaqWhereInput
    pageTitle: String
    "All values containing the given string."
    pageTitle_contains: String
    "All values ending with the given string."
    pageTitle_ends_with: String
    "All values that are contained in given list."
    pageTitle_in: [String!]
    "All values that are not equal to given value."
    pageTitle_not: String
    "All values not containing the given string."
    pageTitle_not_contains: String
    "All values not ending with the given string"
    pageTitle_not_ends_with: String
    "All values that are not contained in given list."
    pageTitle_not_in: [String!]
    "All values not starting with the given string."
    pageTitle_not_starts_with: String
    "All values starting with the given string."
    pageTitle_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References FaqPage record uniquely"
input FaqPageWhereUniqueInput {
    id: ID
    pageTitle: String
}

input FaqUpdateInput {
    answer: RichTextAST
    faqPage: FaqPageUpdateManyInlineInput
    markdown: String
    question: String
}

input FaqUpdateManyInlineInput {
    "Connect multiple existing Faq documents"
    connect: [FaqConnectInput!]
    "Create and connect multiple Faq documents"
    create: [FaqCreateInput!]
    "Delete multiple Faq documents"
    delete: [FaqWhereUniqueInput!]
    "Disconnect multiple Faq documents"
    disconnect: [FaqWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Faq documents"
    set: [FaqWhereUniqueInput!]
    "Update multiple Faq documents"
    update: [FaqUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Faq documents"
    upsert: [FaqUpsertWithNestedWhereUniqueInput!]
}

input FaqUpdateManyInput {
    answer: RichTextAST
    markdown: String
}

input FaqUpdateManyWithNestedWhereInput {
    "Update many input"
    data: FaqUpdateManyInput!
    "Document search"
    where: FaqWhereInput!
}

input FaqUpdateOneInlineInput {
    "Connect existing Faq document"
    connect: FaqWhereUniqueInput
    "Create and connect one Faq document"
    create: FaqCreateInput
    "Delete currently connected Faq document"
    delete: Boolean
    "Disconnect currently connected Faq document"
    disconnect: Boolean
    "Update single Faq document"
    update: FaqUpdateWithNestedWhereUniqueInput
    "Upsert single Faq document"
    upsert: FaqUpsertWithNestedWhereUniqueInput
}

input FaqUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: FaqUpdateInput!
    "Unique document search"
    where: FaqWhereUniqueInput!
}

input FaqUpsertInput {
    "Create document if it didn't exist"
    create: FaqCreateInput!
    "Update document if it exists"
    update: FaqUpdateInput!
}

input FaqUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: FaqUpsertInput!
    "Unique document search"
    where: FaqWhereUniqueInput!
}

"Identifies documents"
input FaqWhereInput {
    "Logical AND on all given filters."
    AND: [FaqWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [FaqWhereInput!]
    "Logical OR on all given filters."
    OR: [FaqWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    faqPage_every: FaqPageWhereInput
    faqPage_none: FaqPageWhereInput
    faqPage_some: FaqPageWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    markdown: String
    "All values containing the given string."
    markdown_contains: String
    "All values ending with the given string."
    markdown_ends_with: String
    "All values that are contained in given list."
    markdown_in: [String!]
    "All values that are not equal to given value."
    markdown_not: String
    "All values not containing the given string."
    markdown_not_contains: String
    "All values not ending with the given string"
    markdown_not_ends_with: String
    "All values that are not contained in given list."
    markdown_not_in: [String!]
    "All values not starting with the given string."
    markdown_not_starts_with: String
    "All values starting with the given string."
    markdown_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    question: String
    "All values containing the given string."
    question_contains: String
    "All values ending with the given string."
    question_ends_with: String
    "All values that are contained in given list."
    question_in: [String!]
    "All values that are not equal to given value."
    question_not: String
    "All values not containing the given string."
    question_not_contains: String
    "All values not ending with the given string"
    question_not_ends_with: String
    "All values that are not contained in given list."
    question_not_in: [String!]
    "All values not starting with the given string."
    question_not_starts_with: String
    "All values starting with the given string."
    question_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Faq record uniquely"
input FaqWhereUniqueInput {
    id: ID
    question: String
}

input ImageResizeInput {
    "The default value for the fit parameter is fit:clip."
    fit: ImageFit
    "The height in pixels to resize the image to. The value must be an integer from 1 to 10000."
    height: Int
    "The width in pixels to resize the image to. The value must be an integer from 1 to 10000."
    width: Int
}

"Transformations for Images"
input ImageTransformationInput {
    "Resizes the image"
    resize: ImageResizeInput
}

input InstructorConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: InstructorWhereUniqueInput!
}

input InstructorCreateInput {
    bio: RichTextAST
    class: ClassCreateManyInlineInput
    createdAt: DateTime
    defaultInstructor: Boolean
    firstName: String!
    headshotImage: AssetCreateOneInlineInput
    instructorStatement: RichTextAST
    isStaff: Boolean!
    lastName: String!
    staffBio: RichTextAST
    staffPicture: AssetCreateOneInlineInput
    staffTitle: String
    updatedAt: DateTime
}

input InstructorCreateManyInlineInput {
    "Connect multiple existing Instructor documents"
    connect: [InstructorWhereUniqueInput!]
    "Create and connect multiple existing Instructor documents"
    create: [InstructorCreateInput!]
}

input InstructorCreateOneInlineInput {
    "Connect one existing Instructor document"
    connect: InstructorWhereUniqueInput
    "Create and connect one Instructor document"
    create: InstructorCreateInput
}

"Identifies documents"
input InstructorManyWhereInput {
    "Logical AND on all given filters."
    AND: [InstructorWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [InstructorWhereInput!]
    "Logical OR on all given filters."
    OR: [InstructorWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    class_every: ClassWhereInput
    class_none: ClassWhereInput
    class_some: ClassWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    defaultInstructor: Boolean
    "All values that are not equal to given value."
    defaultInstructor_not: Boolean
    firstName: String
    "All values containing the given string."
    firstName_contains: String
    "All values ending with the given string."
    firstName_ends_with: String
    "All values that are contained in given list."
    firstName_in: [String!]
    "All values that are not equal to given value."
    firstName_not: String
    "All values not containing the given string."
    firstName_not_contains: String
    "All values not ending with the given string"
    firstName_not_ends_with: String
    "All values that are not contained in given list."
    firstName_not_in: [String!]
    "All values not starting with the given string."
    firstName_not_starts_with: String
    "All values starting with the given string."
    firstName_starts_with: String
    headshotImage: AssetWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isStaff: Boolean
    "All values that are not equal to given value."
    isStaff_not: Boolean
    lastName: String
    "All values containing the given string."
    lastName_contains: String
    "All values ending with the given string."
    lastName_ends_with: String
    "All values that are contained in given list."
    lastName_in: [String!]
    "All values that are not equal to given value."
    lastName_not: String
    "All values not containing the given string."
    lastName_not_contains: String
    "All values not ending with the given string"
    lastName_not_ends_with: String
    "All values that are not contained in given list."
    lastName_not_in: [String!]
    "All values not starting with the given string."
    lastName_not_starts_with: String
    "All values starting with the given string."
    lastName_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    staffPicture: AssetWhereInput
    staffTitle: String
    "All values containing the given string."
    staffTitle_contains: String
    "All values ending with the given string."
    staffTitle_ends_with: String
    "All values that are contained in given list."
    staffTitle_in: [String!]
    "All values that are not equal to given value."
    staffTitle_not: String
    "All values not containing the given string."
    staffTitle_not_contains: String
    "All values not ending with the given string"
    staffTitle_not_ends_with: String
    "All values that are not contained in given list."
    staffTitle_not_in: [String!]
    "All values not starting with the given string."
    staffTitle_not_starts_with: String
    "All values starting with the given string."
    staffTitle_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input InstructorUpdateInput {
    bio: RichTextAST
    class: ClassUpdateManyInlineInput
    defaultInstructor: Boolean
    firstName: String
    headshotImage: AssetUpdateOneInlineInput
    instructorStatement: RichTextAST
    isStaff: Boolean
    lastName: String
    staffBio: RichTextAST
    staffPicture: AssetUpdateOneInlineInput
    staffTitle: String
}

input InstructorUpdateManyInlineInput {
    "Connect multiple existing Instructor documents"
    connect: [InstructorConnectInput!]
    "Create and connect multiple Instructor documents"
    create: [InstructorCreateInput!]
    "Delete multiple Instructor documents"
    delete: [InstructorWhereUniqueInput!]
    "Disconnect multiple Instructor documents"
    disconnect: [InstructorWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Instructor documents"
    set: [InstructorWhereUniqueInput!]
    "Update multiple Instructor documents"
    update: [InstructorUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Instructor documents"
    upsert: [InstructorUpsertWithNestedWhereUniqueInput!]
}

input InstructorUpdateManyInput {
    bio: RichTextAST
    firstName: String
    instructorStatement: RichTextAST
    isStaff: Boolean
    lastName: String
    staffBio: RichTextAST
    staffTitle: String
}

input InstructorUpdateManyWithNestedWhereInput {
    "Update many input"
    data: InstructorUpdateManyInput!
    "Document search"
    where: InstructorWhereInput!
}

input InstructorUpdateOneInlineInput {
    "Connect existing Instructor document"
    connect: InstructorWhereUniqueInput
    "Create and connect one Instructor document"
    create: InstructorCreateInput
    "Delete currently connected Instructor document"
    delete: Boolean
    "Disconnect currently connected Instructor document"
    disconnect: Boolean
    "Update single Instructor document"
    update: InstructorUpdateWithNestedWhereUniqueInput
    "Upsert single Instructor document"
    upsert: InstructorUpsertWithNestedWhereUniqueInput
}

input InstructorUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: InstructorUpdateInput!
    "Unique document search"
    where: InstructorWhereUniqueInput!
}

input InstructorUpsertInput {
    "Create document if it didn't exist"
    create: InstructorCreateInput!
    "Update document if it exists"
    update: InstructorUpdateInput!
}

input InstructorUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: InstructorUpsertInput!
    "Unique document search"
    where: InstructorWhereUniqueInput!
}

"Identifies documents"
input InstructorWhereInput {
    "Logical AND on all given filters."
    AND: [InstructorWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [InstructorWhereInput!]
    "Logical OR on all given filters."
    OR: [InstructorWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    class_every: ClassWhereInput
    class_none: ClassWhereInput
    class_some: ClassWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    defaultInstructor: Boolean
    "All values that are not equal to given value."
    defaultInstructor_not: Boolean
    firstName: String
    "All values containing the given string."
    firstName_contains: String
    "All values ending with the given string."
    firstName_ends_with: String
    "All values that are contained in given list."
    firstName_in: [String!]
    "All values that are not equal to given value."
    firstName_not: String
    "All values not containing the given string."
    firstName_not_contains: String
    "All values not ending with the given string"
    firstName_not_ends_with: String
    "All values that are not contained in given list."
    firstName_not_in: [String!]
    "All values not starting with the given string."
    firstName_not_starts_with: String
    "All values starting with the given string."
    firstName_starts_with: String
    headshotImage: AssetWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isStaff: Boolean
    "All values that are not equal to given value."
    isStaff_not: Boolean
    lastName: String
    "All values containing the given string."
    lastName_contains: String
    "All values ending with the given string."
    lastName_ends_with: String
    "All values that are contained in given list."
    lastName_in: [String!]
    "All values that are not equal to given value."
    lastName_not: String
    "All values not containing the given string."
    lastName_not_contains: String
    "All values not ending with the given string"
    lastName_not_ends_with: String
    "All values that are not contained in given list."
    lastName_not_in: [String!]
    "All values not starting with the given string."
    lastName_not_starts_with: String
    "All values starting with the given string."
    lastName_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    staffPicture: AssetWhereInput
    staffTitle: String
    "All values containing the given string."
    staffTitle_contains: String
    "All values ending with the given string."
    staffTitle_ends_with: String
    "All values that are contained in given list."
    staffTitle_in: [String!]
    "All values that are not equal to given value."
    staffTitle_not: String
    "All values not containing the given string."
    staffTitle_not_contains: String
    "All values not ending with the given string"
    staffTitle_not_ends_with: String
    "All values that are not contained in given list."
    staffTitle_not_in: [String!]
    "All values not starting with the given string."
    staffTitle_not_starts_with: String
    "All values starting with the given string."
    staffTitle_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Instructor record uniquely"
input InstructorWhereUniqueInput {
    defaultInstructor: Boolean
    id: ID
}

"Input for a geolocation point with latitude and longitude"
input LocationInput {
    latitude: Float!
    longitude: Float!
}

input MembershipCategoryConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: MembershipCategoryWhereUniqueInput!
}

input MembershipCategoryCreateInput {
    createdAt: DateTime
    membershipTiers: MembershipTierCreateManyInlineInput
    title: String!
    updatedAt: DateTime
}

input MembershipCategoryCreateManyInlineInput {
    "Connect multiple existing MembershipCategory documents"
    connect: [MembershipCategoryWhereUniqueInput!]
    "Create and connect multiple existing MembershipCategory documents"
    create: [MembershipCategoryCreateInput!]
}

input MembershipCategoryCreateOneInlineInput {
    "Connect one existing MembershipCategory document"
    connect: MembershipCategoryWhereUniqueInput
    "Create and connect one MembershipCategory document"
    create: MembershipCategoryCreateInput
}

"Identifies documents"
input MembershipCategoryManyWhereInput {
    "Logical AND on all given filters."
    AND: [MembershipCategoryWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [MembershipCategoryWhereInput!]
    "Logical OR on all given filters."
    OR: [MembershipCategoryWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    membershipTiers_every: MembershipTierWhereInput
    membershipTiers_none: MembershipTierWhereInput
    membershipTiers_some: MembershipTierWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input MembershipCategoryUpdateInput {
    membershipTiers: MembershipTierUpdateManyInlineInput
    title: String
}

input MembershipCategoryUpdateManyInlineInput {
    "Connect multiple existing MembershipCategory documents"
    connect: [MembershipCategoryConnectInput!]
    "Create and connect multiple MembershipCategory documents"
    create: [MembershipCategoryCreateInput!]
    "Delete multiple MembershipCategory documents"
    delete: [MembershipCategoryWhereUniqueInput!]
    "Disconnect multiple MembershipCategory documents"
    disconnect: [MembershipCategoryWhereUniqueInput!]
    "Override currently-connected documents with multiple existing MembershipCategory documents"
    set: [MembershipCategoryWhereUniqueInput!]
    "Update multiple MembershipCategory documents"
    update: [MembershipCategoryUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple MembershipCategory documents"
    upsert: [MembershipCategoryUpsertWithNestedWhereUniqueInput!]
}

input MembershipCategoryUpdateManyInput {
    "No fields in updateMany data input"
    _: String
}

input MembershipCategoryUpdateManyWithNestedWhereInput {
    "Update many input"
    data: MembershipCategoryUpdateManyInput!
    "Document search"
    where: MembershipCategoryWhereInput!
}

input MembershipCategoryUpdateOneInlineInput {
    "Connect existing MembershipCategory document"
    connect: MembershipCategoryWhereUniqueInput
    "Create and connect one MembershipCategory document"
    create: MembershipCategoryCreateInput
    "Delete currently connected MembershipCategory document"
    delete: Boolean
    "Disconnect currently connected MembershipCategory document"
    disconnect: Boolean
    "Update single MembershipCategory document"
    update: MembershipCategoryUpdateWithNestedWhereUniqueInput
    "Upsert single MembershipCategory document"
    upsert: MembershipCategoryUpsertWithNestedWhereUniqueInput
}

input MembershipCategoryUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: MembershipCategoryUpdateInput!
    "Unique document search"
    where: MembershipCategoryWhereUniqueInput!
}

input MembershipCategoryUpsertInput {
    "Create document if it didn't exist"
    create: MembershipCategoryCreateInput!
    "Update document if it exists"
    update: MembershipCategoryUpdateInput!
}

input MembershipCategoryUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: MembershipCategoryUpsertInput!
    "Unique document search"
    where: MembershipCategoryWhereUniqueInput!
}

"Identifies documents"
input MembershipCategoryWhereInput {
    "Logical AND on all given filters."
    AND: [MembershipCategoryWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [MembershipCategoryWhereInput!]
    "Logical OR on all given filters."
    OR: [MembershipCategoryWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    membershipTiers_every: MembershipTierWhereInput
    membershipTiers_none: MembershipTierWhereInput
    membershipTiers_some: MembershipTierWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References MembershipCategory record uniquely"
input MembershipCategoryWhereUniqueInput {
    id: ID
    title: String
}

input MembershipTierConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: MembershipTierWhereUniqueInput!
}

input MembershipTierCreateInput {
    buttonText: String!
    buttonVariant: ButtonVariant!
    category: MembershipCategoryCreateOneInlineInput
    createdAt: DateTime
    description: [String!]!
    inputValue: String!
    price: Int!
    term: MembershipTerm!
    testCategory: TestCategoryCreateManyInlineInput
    title: String!
    updatedAt: DateTime
}

input MembershipTierCreateManyInlineInput {
    "Connect multiple existing MembershipTier documents"
    connect: [MembershipTierWhereUniqueInput!]
    "Create and connect multiple existing MembershipTier documents"
    create: [MembershipTierCreateInput!]
}

input MembershipTierCreateOneInlineInput {
    "Connect one existing MembershipTier document"
    connect: MembershipTierWhereUniqueInput
    "Create and connect one MembershipTier document"
    create: MembershipTierCreateInput
}

"Identifies documents"
input MembershipTierManyWhereInput {
    "Logical AND on all given filters."
    AND: [MembershipTierWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [MembershipTierWhereInput!]
    "Logical OR on all given filters."
    OR: [MembershipTierWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    buttonText: String
    "All values containing the given string."
    buttonText_contains: String
    "All values ending with the given string."
    buttonText_ends_with: String
    "All values that are contained in given list."
    buttonText_in: [String!]
    "All values that are not equal to given value."
    buttonText_not: String
    "All values not containing the given string."
    buttonText_not_contains: String
    "All values not ending with the given string"
    buttonText_not_ends_with: String
    "All values that are not contained in given list."
    buttonText_not_in: [String!]
    "All values not starting with the given string."
    buttonText_not_starts_with: String
    "All values starting with the given string."
    buttonText_starts_with: String
    buttonVariant: ButtonVariant
    "All values that are contained in given list."
    buttonVariant_in: [ButtonVariant!]
    "All values that are not equal to given value."
    buttonVariant_not: ButtonVariant
    "All values that are not contained in given list."
    buttonVariant_not_in: [ButtonVariant!]
    category: MembershipCategoryWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    description: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    description_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    description_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    description_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    description_not: [String!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    inputValue: String
    "All values containing the given string."
    inputValue_contains: String
    "All values ending with the given string."
    inputValue_ends_with: String
    "All values that are contained in given list."
    inputValue_in: [String!]
    "All values that are not equal to given value."
    inputValue_not: String
    "All values not containing the given string."
    inputValue_not_contains: String
    "All values not ending with the given string"
    inputValue_not_ends_with: String
    "All values that are not contained in given list."
    inputValue_not_in: [String!]
    "All values not starting with the given string."
    inputValue_not_starts_with: String
    "All values starting with the given string."
    inputValue_starts_with: String
    price: Int
    "All values greater than the given value."
    price_gt: Int
    "All values greater than or equal the given value."
    price_gte: Int
    "All values that are contained in given list."
    price_in: [Int!]
    "All values less than the given value."
    price_lt: Int
    "All values less than or equal the given value."
    price_lte: Int
    "All values that are not equal to given value."
    price_not: Int
    "All values that are not contained in given list."
    price_not_in: [Int!]
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    term: MembershipTerm
    "All values that are contained in given list."
    term_in: [MembershipTerm!]
    "All values that are not equal to given value."
    term_not: MembershipTerm
    "All values that are not contained in given list."
    term_not_in: [MembershipTerm!]
    testCategory_every: TestCategoryWhereInput
    testCategory_none: TestCategoryWhereInput
    testCategory_some: TestCategoryWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input MembershipTierUpdateInput {
    buttonText: String
    buttonVariant: ButtonVariant
    category: MembershipCategoryUpdateOneInlineInput
    description: [String!]
    inputValue: String
    price: Int
    term: MembershipTerm
    testCategory: TestCategoryUpdateManyInlineInput
    title: String
}

input MembershipTierUpdateManyInlineInput {
    "Connect multiple existing MembershipTier documents"
    connect: [MembershipTierConnectInput!]
    "Create and connect multiple MembershipTier documents"
    create: [MembershipTierCreateInput!]
    "Delete multiple MembershipTier documents"
    delete: [MembershipTierWhereUniqueInput!]
    "Disconnect multiple MembershipTier documents"
    disconnect: [MembershipTierWhereUniqueInput!]
    "Override currently-connected documents with multiple existing MembershipTier documents"
    set: [MembershipTierWhereUniqueInput!]
    "Update multiple MembershipTier documents"
    update: [MembershipTierUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple MembershipTier documents"
    upsert: [MembershipTierUpsertWithNestedWhereUniqueInput!]
}

input MembershipTierUpdateManyInput {
    buttonText: String
    buttonVariant: ButtonVariant
    description: [String!]
    price: Int
    term: MembershipTerm
}

input MembershipTierUpdateManyWithNestedWhereInput {
    "Update many input"
    data: MembershipTierUpdateManyInput!
    "Document search"
    where: MembershipTierWhereInput!
}

input MembershipTierUpdateOneInlineInput {
    "Connect existing MembershipTier document"
    connect: MembershipTierWhereUniqueInput
    "Create and connect one MembershipTier document"
    create: MembershipTierCreateInput
    "Delete currently connected MembershipTier document"
    delete: Boolean
    "Disconnect currently connected MembershipTier document"
    disconnect: Boolean
    "Update single MembershipTier document"
    update: MembershipTierUpdateWithNestedWhereUniqueInput
    "Upsert single MembershipTier document"
    upsert: MembershipTierUpsertWithNestedWhereUniqueInput
}

input MembershipTierUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: MembershipTierUpdateInput!
    "Unique document search"
    where: MembershipTierWhereUniqueInput!
}

input MembershipTierUpsertInput {
    "Create document if it didn't exist"
    create: MembershipTierCreateInput!
    "Update document if it exists"
    update: MembershipTierUpdateInput!
}

input MembershipTierUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: MembershipTierUpsertInput!
    "Unique document search"
    where: MembershipTierWhereUniqueInput!
}

"Identifies documents"
input MembershipTierWhereInput {
    "Logical AND on all given filters."
    AND: [MembershipTierWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [MembershipTierWhereInput!]
    "Logical OR on all given filters."
    OR: [MembershipTierWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    buttonText: String
    "All values containing the given string."
    buttonText_contains: String
    "All values ending with the given string."
    buttonText_ends_with: String
    "All values that are contained in given list."
    buttonText_in: [String!]
    "All values that are not equal to given value."
    buttonText_not: String
    "All values not containing the given string."
    buttonText_not_contains: String
    "All values not ending with the given string"
    buttonText_not_ends_with: String
    "All values that are not contained in given list."
    buttonText_not_in: [String!]
    "All values not starting with the given string."
    buttonText_not_starts_with: String
    "All values starting with the given string."
    buttonText_starts_with: String
    buttonVariant: ButtonVariant
    "All values that are contained in given list."
    buttonVariant_in: [ButtonVariant!]
    "All values that are not equal to given value."
    buttonVariant_not: ButtonVariant
    "All values that are not contained in given list."
    buttonVariant_not_in: [ButtonVariant!]
    category: MembershipCategoryWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    description: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    description_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    description_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    description_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    description_not: [String!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    inputValue: String
    "All values containing the given string."
    inputValue_contains: String
    "All values ending with the given string."
    inputValue_ends_with: String
    "All values that are contained in given list."
    inputValue_in: [String!]
    "All values that are not equal to given value."
    inputValue_not: String
    "All values not containing the given string."
    inputValue_not_contains: String
    "All values not ending with the given string"
    inputValue_not_ends_with: String
    "All values that are not contained in given list."
    inputValue_not_in: [String!]
    "All values not starting with the given string."
    inputValue_not_starts_with: String
    "All values starting with the given string."
    inputValue_starts_with: String
    price: Int
    "All values greater than the given value."
    price_gt: Int
    "All values greater than or equal the given value."
    price_gte: Int
    "All values that are contained in given list."
    price_in: [Int!]
    "All values less than the given value."
    price_lt: Int
    "All values less than or equal the given value."
    price_lte: Int
    "All values that are not equal to given value."
    price_not: Int
    "All values that are not contained in given list."
    price_not_in: [Int!]
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    term: MembershipTerm
    "All values that are contained in given list."
    term_in: [MembershipTerm!]
    "All values that are not equal to given value."
    term_not: MembershipTerm
    "All values that are not contained in given list."
    term_not_in: [MembershipTerm!]
    testCategory_every: TestCategoryWhereInput
    testCategory_none: TestCategoryWhereInput
    testCategory_some: TestCategoryWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References MembershipTier record uniquely"
input MembershipTierWhereUniqueInput {
    id: ID
    inputValue: String
    title: String
}

input PageConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: PageWhereUniqueInput!
}

input PageCreateInput {
    brandedHeader: String!
    createdAt: DateTime
    headerBody: String
    metaDescription: String!
    pageEndpoint: String!
    pageTitle: String!
    updatedAt: DateTime
}

input PageCreateManyInlineInput {
    "Connect multiple existing Page documents"
    connect: [PageWhereUniqueInput!]
    "Create and connect multiple existing Page documents"
    create: [PageCreateInput!]
}

input PageCreateOneInlineInput {
    "Connect one existing Page document"
    connect: PageWhereUniqueInput
    "Create and connect one Page document"
    create: PageCreateInput
}

"Identifies documents"
input PageManyWhereInput {
    "Logical AND on all given filters."
    AND: [PageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [PageWhereInput!]
    "Logical OR on all given filters."
    OR: [PageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    brandedHeader: String
    "All values containing the given string."
    brandedHeader_contains: String
    "All values ending with the given string."
    brandedHeader_ends_with: String
    "All values that are contained in given list."
    brandedHeader_in: [String!]
    "All values that are not equal to given value."
    brandedHeader_not: String
    "All values not containing the given string."
    brandedHeader_not_contains: String
    "All values not ending with the given string"
    brandedHeader_not_ends_with: String
    "All values that are not contained in given list."
    brandedHeader_not_in: [String!]
    "All values not starting with the given string."
    brandedHeader_not_starts_with: String
    "All values starting with the given string."
    brandedHeader_starts_with: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    headerBody: String
    "All values containing the given string."
    headerBody_contains: String
    "All values ending with the given string."
    headerBody_ends_with: String
    "All values that are contained in given list."
    headerBody_in: [String!]
    "All values that are not equal to given value."
    headerBody_not: String
    "All values not containing the given string."
    headerBody_not_contains: String
    "All values not ending with the given string"
    headerBody_not_ends_with: String
    "All values that are not contained in given list."
    headerBody_not_in: [String!]
    "All values not starting with the given string."
    headerBody_not_starts_with: String
    "All values starting with the given string."
    headerBody_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    metaDescription: String
    "All values containing the given string."
    metaDescription_contains: String
    "All values ending with the given string."
    metaDescription_ends_with: String
    "All values that are contained in given list."
    metaDescription_in: [String!]
    "All values that are not equal to given value."
    metaDescription_not: String
    "All values not containing the given string."
    metaDescription_not_contains: String
    "All values not ending with the given string"
    metaDescription_not_ends_with: String
    "All values that are not contained in given list."
    metaDescription_not_in: [String!]
    "All values not starting with the given string."
    metaDescription_not_starts_with: String
    "All values starting with the given string."
    metaDescription_starts_with: String
    pageEndpoint: String
    "All values containing the given string."
    pageEndpoint_contains: String
    "All values ending with the given string."
    pageEndpoint_ends_with: String
    "All values that are contained in given list."
    pageEndpoint_in: [String!]
    "All values that are not equal to given value."
    pageEndpoint_not: String
    "All values not containing the given string."
    pageEndpoint_not_contains: String
    "All values not ending with the given string"
    pageEndpoint_not_ends_with: String
    "All values that are not contained in given list."
    pageEndpoint_not_in: [String!]
    "All values not starting with the given string."
    pageEndpoint_not_starts_with: String
    "All values starting with the given string."
    pageEndpoint_starts_with: String
    pageTitle: String
    "All values containing the given string."
    pageTitle_contains: String
    "All values ending with the given string."
    pageTitle_ends_with: String
    "All values that are contained in given list."
    pageTitle_in: [String!]
    "All values that are not equal to given value."
    pageTitle_not: String
    "All values not containing the given string."
    pageTitle_not_contains: String
    "All values not ending with the given string"
    pageTitle_not_ends_with: String
    "All values that are not contained in given list."
    pageTitle_not_in: [String!]
    "All values not starting with the given string."
    pageTitle_not_starts_with: String
    "All values starting with the given string."
    pageTitle_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input PageUpdateInput {
    brandedHeader: String
    headerBody: String
    metaDescription: String
    pageEndpoint: String
    pageTitle: String
}

input PageUpdateManyInlineInput {
    "Connect multiple existing Page documents"
    connect: [PageConnectInput!]
    "Create and connect multiple Page documents"
    create: [PageCreateInput!]
    "Delete multiple Page documents"
    delete: [PageWhereUniqueInput!]
    "Disconnect multiple Page documents"
    disconnect: [PageWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Page documents"
    set: [PageWhereUniqueInput!]
    "Update multiple Page documents"
    update: [PageUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Page documents"
    upsert: [PageUpsertWithNestedWhereUniqueInput!]
}

input PageUpdateManyInput {
    brandedHeader: String
    headerBody: String
    metaDescription: String
}

input PageUpdateManyWithNestedWhereInput {
    "Update many input"
    data: PageUpdateManyInput!
    "Document search"
    where: PageWhereInput!
}

input PageUpdateOneInlineInput {
    "Connect existing Page document"
    connect: PageWhereUniqueInput
    "Create and connect one Page document"
    create: PageCreateInput
    "Delete currently connected Page document"
    delete: Boolean
    "Disconnect currently connected Page document"
    disconnect: Boolean
    "Update single Page document"
    update: PageUpdateWithNestedWhereUniqueInput
    "Upsert single Page document"
    upsert: PageUpsertWithNestedWhereUniqueInput
}

input PageUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: PageUpdateInput!
    "Unique document search"
    where: PageWhereUniqueInput!
}

input PageUpsertInput {
    "Create document if it didn't exist"
    create: PageCreateInput!
    "Update document if it exists"
    update: PageUpdateInput!
}

input PageUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: PageUpsertInput!
    "Unique document search"
    where: PageWhereUniqueInput!
}

"Identifies documents"
input PageWhereInput {
    "Logical AND on all given filters."
    AND: [PageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [PageWhereInput!]
    "Logical OR on all given filters."
    OR: [PageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    brandedHeader: String
    "All values containing the given string."
    brandedHeader_contains: String
    "All values ending with the given string."
    brandedHeader_ends_with: String
    "All values that are contained in given list."
    brandedHeader_in: [String!]
    "All values that are not equal to given value."
    brandedHeader_not: String
    "All values not containing the given string."
    brandedHeader_not_contains: String
    "All values not ending with the given string"
    brandedHeader_not_ends_with: String
    "All values that are not contained in given list."
    brandedHeader_not_in: [String!]
    "All values not starting with the given string."
    brandedHeader_not_starts_with: String
    "All values starting with the given string."
    brandedHeader_starts_with: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    headerBody: String
    "All values containing the given string."
    headerBody_contains: String
    "All values ending with the given string."
    headerBody_ends_with: String
    "All values that are contained in given list."
    headerBody_in: [String!]
    "All values that are not equal to given value."
    headerBody_not: String
    "All values not containing the given string."
    headerBody_not_contains: String
    "All values not ending with the given string"
    headerBody_not_ends_with: String
    "All values that are not contained in given list."
    headerBody_not_in: [String!]
    "All values not starting with the given string."
    headerBody_not_starts_with: String
    "All values starting with the given string."
    headerBody_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    metaDescription: String
    "All values containing the given string."
    metaDescription_contains: String
    "All values ending with the given string."
    metaDescription_ends_with: String
    "All values that are contained in given list."
    metaDescription_in: [String!]
    "All values that are not equal to given value."
    metaDescription_not: String
    "All values not containing the given string."
    metaDescription_not_contains: String
    "All values not ending with the given string"
    metaDescription_not_ends_with: String
    "All values that are not contained in given list."
    metaDescription_not_in: [String!]
    "All values not starting with the given string."
    metaDescription_not_starts_with: String
    "All values starting with the given string."
    metaDescription_starts_with: String
    pageEndpoint: String
    "All values containing the given string."
    pageEndpoint_contains: String
    "All values ending with the given string."
    pageEndpoint_ends_with: String
    "All values that are contained in given list."
    pageEndpoint_in: [String!]
    "All values that are not equal to given value."
    pageEndpoint_not: String
    "All values not containing the given string."
    pageEndpoint_not_contains: String
    "All values not ending with the given string"
    pageEndpoint_not_ends_with: String
    "All values that are not contained in given list."
    pageEndpoint_not_in: [String!]
    "All values not starting with the given string."
    pageEndpoint_not_starts_with: String
    "All values starting with the given string."
    pageEndpoint_starts_with: String
    pageTitle: String
    "All values containing the given string."
    pageTitle_contains: String
    "All values ending with the given string."
    pageTitle_ends_with: String
    "All values that are contained in given list."
    pageTitle_in: [String!]
    "All values that are not equal to given value."
    pageTitle_not: String
    "All values not containing the given string."
    pageTitle_not_contains: String
    "All values not ending with the given string"
    pageTitle_not_ends_with: String
    "All values that are not contained in given list."
    pageTitle_not_in: [String!]
    "All values not starting with the given string."
    pageTitle_not_starts_with: String
    "All values starting with the given string."
    pageTitle_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Page record uniquely"
input PageWhereUniqueInput {
    id: ID
    pageEndpoint: String
    pageTitle: String
}

input PolicyConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: PolicyWhereUniqueInput!
}

input PolicyCreateInput {
    createdAt: DateTime
    policyName: String!
    policyText: RichTextAST
    updatedAt: DateTime
}

input PolicyCreateManyInlineInput {
    "Connect multiple existing Policy documents"
    connect: [PolicyWhereUniqueInput!]
    "Create and connect multiple existing Policy documents"
    create: [PolicyCreateInput!]
}

input PolicyCreateOneInlineInput {
    "Connect one existing Policy document"
    connect: PolicyWhereUniqueInput
    "Create and connect one Policy document"
    create: PolicyCreateInput
}

"Identifies documents"
input PolicyManyWhereInput {
    "Logical AND on all given filters."
    AND: [PolicyWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [PolicyWhereInput!]
    "Logical OR on all given filters."
    OR: [PolicyWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    policyName: String
    "All values containing the given string."
    policyName_contains: String
    "All values ending with the given string."
    policyName_ends_with: String
    "All values that are contained in given list."
    policyName_in: [String!]
    "All values that are not equal to given value."
    policyName_not: String
    "All values not containing the given string."
    policyName_not_contains: String
    "All values not ending with the given string"
    policyName_not_ends_with: String
    "All values that are not contained in given list."
    policyName_not_in: [String!]
    "All values not starting with the given string."
    policyName_not_starts_with: String
    "All values starting with the given string."
    policyName_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input PolicyUpdateInput {
    policyName: String
    policyText: RichTextAST
}

input PolicyUpdateManyInlineInput {
    "Connect multiple existing Policy documents"
    connect: [PolicyConnectInput!]
    "Create and connect multiple Policy documents"
    create: [PolicyCreateInput!]
    "Delete multiple Policy documents"
    delete: [PolicyWhereUniqueInput!]
    "Disconnect multiple Policy documents"
    disconnect: [PolicyWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Policy documents"
    set: [PolicyWhereUniqueInput!]
    "Update multiple Policy documents"
    update: [PolicyUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Policy documents"
    upsert: [PolicyUpsertWithNestedWhereUniqueInput!]
}

input PolicyUpdateManyInput {
    policyName: String
    policyText: RichTextAST
}

input PolicyUpdateManyWithNestedWhereInput {
    "Update many input"
    data: PolicyUpdateManyInput!
    "Document search"
    where: PolicyWhereInput!
}

input PolicyUpdateOneInlineInput {
    "Connect existing Policy document"
    connect: PolicyWhereUniqueInput
    "Create and connect one Policy document"
    create: PolicyCreateInput
    "Delete currently connected Policy document"
    delete: Boolean
    "Disconnect currently connected Policy document"
    disconnect: Boolean
    "Update single Policy document"
    update: PolicyUpdateWithNestedWhereUniqueInput
    "Upsert single Policy document"
    upsert: PolicyUpsertWithNestedWhereUniqueInput
}

input PolicyUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: PolicyUpdateInput!
    "Unique document search"
    where: PolicyWhereUniqueInput!
}

input PolicyUpsertInput {
    "Create document if it didn't exist"
    create: PolicyCreateInput!
    "Update document if it exists"
    update: PolicyUpdateInput!
}

input PolicyUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: PolicyUpsertInput!
    "Unique document search"
    where: PolicyWhereUniqueInput!
}

"Identifies documents"
input PolicyWhereInput {
    "Logical AND on all given filters."
    AND: [PolicyWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [PolicyWhereInput!]
    "Logical OR on all given filters."
    OR: [PolicyWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    policyName: String
    "All values containing the given string."
    policyName_contains: String
    "All values ending with the given string."
    policyName_ends_with: String
    "All values that are contained in given list."
    policyName_in: [String!]
    "All values that are not equal to given value."
    policyName_not: String
    "All values not containing the given string."
    policyName_not_contains: String
    "All values not ending with the given string"
    policyName_not_ends_with: String
    "All values that are not contained in given list."
    policyName_not_in: [String!]
    "All values not starting with the given string."
    policyName_not_starts_with: String
    "All values starting with the given string."
    policyName_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References Policy record uniquely"
input PolicyWhereUniqueInput {
    id: ID
}

input PublishLocaleInput {
    "Locales to publish"
    locale: Locale!
    "Stages to publish selected locales to"
    stages: [Stage!]!
}

"Input type representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
input RGBAInput {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

input TestCategoryConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: TestCategoryWhereUniqueInput!
}

input TestCategoryCreateInput {
    createdAt: DateTime
    membershipTiers: MembershipTierCreateManyInlineInput
    title: String!
    updatedAt: DateTime
}

input TestCategoryCreateManyInlineInput {
    "Connect multiple existing TestCategory documents"
    connect: [TestCategoryWhereUniqueInput!]
    "Create and connect multiple existing TestCategory documents"
    create: [TestCategoryCreateInput!]
}

input TestCategoryCreateOneInlineInput {
    "Connect one existing TestCategory document"
    connect: TestCategoryWhereUniqueInput
    "Create and connect one TestCategory document"
    create: TestCategoryCreateInput
}

"Identifies documents"
input TestCategoryManyWhereInput {
    "Logical AND on all given filters."
    AND: [TestCategoryWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [TestCategoryWhereInput!]
    "Logical OR on all given filters."
    OR: [TestCategoryWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    membershipTiers_every: MembershipTierWhereInput
    membershipTiers_none: MembershipTierWhereInput
    membershipTiers_some: MembershipTierWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input TestCategoryUpdateInput {
    membershipTiers: MembershipTierUpdateManyInlineInput
    title: String
}

input TestCategoryUpdateManyInlineInput {
    "Connect multiple existing TestCategory documents"
    connect: [TestCategoryConnectInput!]
    "Create and connect multiple TestCategory documents"
    create: [TestCategoryCreateInput!]
    "Delete multiple TestCategory documents"
    delete: [TestCategoryWhereUniqueInput!]
    "Disconnect multiple TestCategory documents"
    disconnect: [TestCategoryWhereUniqueInput!]
    "Override currently-connected documents with multiple existing TestCategory documents"
    set: [TestCategoryWhereUniqueInput!]
    "Update multiple TestCategory documents"
    update: [TestCategoryUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple TestCategory documents"
    upsert: [TestCategoryUpsertWithNestedWhereUniqueInput!]
}

input TestCategoryUpdateManyInput {
    "No fields in updateMany data input"
    _: String
}

input TestCategoryUpdateManyWithNestedWhereInput {
    "Update many input"
    data: TestCategoryUpdateManyInput!
    "Document search"
    where: TestCategoryWhereInput!
}

input TestCategoryUpdateOneInlineInput {
    "Connect existing TestCategory document"
    connect: TestCategoryWhereUniqueInput
    "Create and connect one TestCategory document"
    create: TestCategoryCreateInput
    "Delete currently connected TestCategory document"
    delete: Boolean
    "Disconnect currently connected TestCategory document"
    disconnect: Boolean
    "Update single TestCategory document"
    update: TestCategoryUpdateWithNestedWhereUniqueInput
    "Upsert single TestCategory document"
    upsert: TestCategoryUpsertWithNestedWhereUniqueInput
}

input TestCategoryUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: TestCategoryUpdateInput!
    "Unique document search"
    where: TestCategoryWhereUniqueInput!
}

input TestCategoryUpsertInput {
    "Create document if it didn't exist"
    create: TestCategoryCreateInput!
    "Update document if it exists"
    update: TestCategoryUpdateInput!
}

input TestCategoryUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: TestCategoryUpsertInput!
    "Unique document search"
    where: TestCategoryWhereUniqueInput!
}

"Identifies documents"
input TestCategoryWhereInput {
    "Logical AND on all given filters."
    AND: [TestCategoryWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [TestCategoryWhereInput!]
    "Logical OR on all given filters."
    OR: [TestCategoryWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    membershipTiers_every: MembershipTierWhereInput
    membershipTiers_none: MembershipTierWhereInput
    membershipTiers_some: MembershipTierWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References TestCategory record uniquely"
input TestCategoryWhereUniqueInput {
    id: ID
    title: String
}

input UnpublishLocaleInput {
    "Locales to unpublish"
    locale: Locale!
    "Stages to unpublish selected locales from"
    stages: [Stage!]!
}

input UserConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: UserWhereUniqueInput!
}

input UserCreateManyInlineInput {
    "Connect multiple existing User documents"
    connect: [UserWhereUniqueInput!]
}

input UserCreateOneInlineInput {
    "Connect one existing User document"
    connect: UserWhereUniqueInput
}

"Identifies documents"
input UserManyWhereInput {
    "Logical AND on all given filters."
    AND: [UserWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereInput!]
    "Logical OR on all given filters."
    OR: [UserWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "All values that are not equal to given value."
    isActive_not: Boolean
    kind: UserKind
    "All values that are contained in given list."
    kind_in: [UserKind!]
    "All values that are not equal to given value."
    kind_not: UserKind
    "All values that are not contained in given list."
    kind_not_in: [UserKind!]
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    picture: String
    "All values containing the given string."
    picture_contains: String
    "All values ending with the given string."
    picture_ends_with: String
    "All values that are contained in given list."
    picture_in: [String!]
    "All values that are not equal to given value."
    picture_not: String
    "All values not containing the given string."
    picture_not_contains: String
    "All values not ending with the given string"
    picture_not_ends_with: String
    "All values that are not contained in given list."
    picture_not_in: [String!]
    "All values not starting with the given string."
    picture_not_starts_with: String
    "All values starting with the given string."
    picture_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

input UserUpdateManyInlineInput {
    "Connect multiple existing User documents"
    connect: [UserConnectInput!]
    "Disconnect multiple User documents"
    disconnect: [UserWhereUniqueInput!]
    "Override currently-connected documents with multiple existing User documents"
    set: [UserWhereUniqueInput!]
}

input UserUpdateOneInlineInput {
    "Connect existing User document"
    connect: UserWhereUniqueInput
    "Disconnect currently connected User document"
    disconnect: Boolean
}

"Identifies documents"
input UserWhereInput {
    "Logical AND on all given filters."
    AND: [UserWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereInput!]
    "Logical OR on all given filters."
    OR: [UserWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "All values that are not equal to given value."
    isActive_not: Boolean
    kind: UserKind
    "All values that are contained in given list."
    kind_in: [UserKind!]
    "All values that are not equal to given value."
    kind_not: UserKind
    "All values that are not contained in given list."
    kind_not_in: [UserKind!]
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    picture: String
    "All values containing the given string."
    picture_contains: String
    "All values ending with the given string."
    picture_ends_with: String
    "All values that are contained in given list."
    picture_in: [String!]
    "All values that are not equal to given value."
    picture_not: String
    "All values not containing the given string."
    picture_not_contains: String
    "All values not ending with the given string"
    picture_not_ends_with: String
    "All values that are not contained in given list."
    picture_not_in: [String!]
    "All values not starting with the given string."
    picture_not_starts_with: String
    "All values starting with the given string."
    picture_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

"References User record uniquely"
input UserWhereUniqueInput {
    id: ID
}

input VersionWhereInput {
    id: ID!
    revision: Int!
    stage: Stage!
}

input WebsiteDefaultImageConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: WebsiteDefaultImageWhereUniqueInput!
}

input WebsiteDefaultImageCreateInput {
    createdAt: DateTime
    image: AssetCreateOneInlineInput
    title: String
    updatedAt: DateTime
}

input WebsiteDefaultImageCreateManyInlineInput {
    "Connect multiple existing WebsiteDefaultImage documents"
    connect: [WebsiteDefaultImageWhereUniqueInput!]
    "Create and connect multiple existing WebsiteDefaultImage documents"
    create: [WebsiteDefaultImageCreateInput!]
}

input WebsiteDefaultImageCreateOneInlineInput {
    "Connect one existing WebsiteDefaultImage document"
    connect: WebsiteDefaultImageWhereUniqueInput
    "Create and connect one WebsiteDefaultImage document"
    create: WebsiteDefaultImageCreateInput
}

"Identifies documents"
input WebsiteDefaultImageManyWhereInput {
    "Logical AND on all given filters."
    AND: [WebsiteDefaultImageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [WebsiteDefaultImageWhereInput!]
    "Logical OR on all given filters."
    OR: [WebsiteDefaultImageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    image: AssetWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

input WebsiteDefaultImageUpdateInput {
    image: AssetUpdateOneInlineInput
    title: String
}

input WebsiteDefaultImageUpdateManyInlineInput {
    "Connect multiple existing WebsiteDefaultImage documents"
    connect: [WebsiteDefaultImageConnectInput!]
    "Create and connect multiple WebsiteDefaultImage documents"
    create: [WebsiteDefaultImageCreateInput!]
    "Delete multiple WebsiteDefaultImage documents"
    delete: [WebsiteDefaultImageWhereUniqueInput!]
    "Disconnect multiple WebsiteDefaultImage documents"
    disconnect: [WebsiteDefaultImageWhereUniqueInput!]
    "Override currently-connected documents with multiple existing WebsiteDefaultImage documents"
    set: [WebsiteDefaultImageWhereUniqueInput!]
    "Update multiple WebsiteDefaultImage documents"
    update: [WebsiteDefaultImageUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple WebsiteDefaultImage documents"
    upsert: [WebsiteDefaultImageUpsertWithNestedWhereUniqueInput!]
}

input WebsiteDefaultImageUpdateManyInput {
    title: String
}

input WebsiteDefaultImageUpdateManyWithNestedWhereInput {
    "Update many input"
    data: WebsiteDefaultImageUpdateManyInput!
    "Document search"
    where: WebsiteDefaultImageWhereInput!
}

input WebsiteDefaultImageUpdateOneInlineInput {
    "Connect existing WebsiteDefaultImage document"
    connect: WebsiteDefaultImageWhereUniqueInput
    "Create and connect one WebsiteDefaultImage document"
    create: WebsiteDefaultImageCreateInput
    "Delete currently connected WebsiteDefaultImage document"
    delete: Boolean
    "Disconnect currently connected WebsiteDefaultImage document"
    disconnect: Boolean
    "Update single WebsiteDefaultImage document"
    update: WebsiteDefaultImageUpdateWithNestedWhereUniqueInput
    "Upsert single WebsiteDefaultImage document"
    upsert: WebsiteDefaultImageUpsertWithNestedWhereUniqueInput
}

input WebsiteDefaultImageUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: WebsiteDefaultImageUpdateInput!
    "Unique document search"
    where: WebsiteDefaultImageWhereUniqueInput!
}

input WebsiteDefaultImageUpsertInput {
    "Create document if it didn't exist"
    create: WebsiteDefaultImageCreateInput!
    "Update document if it exists"
    update: WebsiteDefaultImageUpdateInput!
}

input WebsiteDefaultImageUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: WebsiteDefaultImageUpsertInput!
    "Unique document search"
    where: WebsiteDefaultImageWhereUniqueInput!
}

"Identifies documents"
input WebsiteDefaultImageWhereInput {
    "Logical AND on all given filters."
    AND: [WebsiteDefaultImageWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [WebsiteDefaultImageWhereInput!]
    "Logical OR on all given filters."
    OR: [WebsiteDefaultImageWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    createdBy: UserWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    image: AssetWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    publishedBy: UserWhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String!]
    "All values that are not equal to given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String!]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    updatedBy: UserWhereInput
}

"References WebsiteDefaultImage record uniquely"
input WebsiteDefaultImageWhereUniqueInput {
    id: ID
}


"A date string, such as 2007-12-03 (YYYY-MM-DD), compliant with ISO 8601 standard for representation of dates using the Gregorian calendar."
scalar Date

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the date-timeformat outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representationof dates and times using the Gregorian calendar."
scalar DateTime

scalar Hex

"Raw JSON value"
scalar Json

"The Long scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar RGBAHue

scalar RGBATransparency

"Slate-compatible RichText AST"
scalar RichTextAST
